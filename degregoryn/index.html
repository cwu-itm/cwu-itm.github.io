<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Nicole DeGregory | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>
         <!-- Module 1.1 Blog Post Starts Here-->
         <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>
            <h3>Systems Thinking in Digital Design</h3>
            <p>Hey everyone! For my first post, I'm exploring systems thinking—a foundational concept in systems engineering and digital environments. In our world today, the things we build aren't just standalone tools anymore. From global logistics to the software architectures running smart cities, everything is interconnected. To handle this complexity, we need a shift in mindset. We have to move away from seeing a product as just a "collection of parts" and start seeing it as a dynamic system.</p>
            
            <h3>Defining Systems Thinking in My Own Words</h3>
            <p>To me, systems thinking is basically the art of seeing the "connective tissue" of a project. Instead of seeing a system as a static machine with a few separate parts, I view it as a dynamic web where everything affects everything else. It's a shift from asking, "What does this one part do?" to "How does this part influence the others, and how does the whole react to that change?"</p>
            <p>According to Jon Holt (2019), the core idea of systems theory is that parts are best understood in the context of their relationships with each other and with other systems, rather than in isolation. This is so important because systems exhibit "emergence." This is a concept that describes how a system as a whole can do things that the individual parts can't do on their own (Holt, 2019).</p>
            <p>Donella Meadows (2008) expands on this by defining a system as more than just a pile of things; it is an "interconnected set of elements that is coherently organized in a way that achieves something" (p. 11). If you ignore the connections, you aren't really seeing the system at all. You just have a list of parts without a purpose. I've found that in my own technical projects, like building risk models, focusing only on the code while ignoring how it interacts with the data inputs always leads to errors. Systems thinking forces you to look at that organization and purpose from the very beginning.</p>
            
            <h3>Breaking the Line: Systems vs. Linear Thinking</h3>
            <p>The biggest difference between systems thinking and traditional linear thinking is the difference between a straight line and a circle.</p>
            <ul>
               <li><strong>Linear Thinking (Reductionism):</strong> This is the "cause-and-effect" approach. It assumes that if you break a problem down into small pieces and fix one piece at a time, you've solved the whole thing. It assumes you can predict how a system will act just by adding up the behaviors of its parts (Holt, 2019).</li>
               <li><strong>Systems Thinking (Holism):</strong> This recognizes feedback loops. As Peter Senge (2006) explains, "systems thinking is a discipline for seeing wholes," which means we can actually identify the hidden patterns in a complex system instead of just focusing on small, isolated events that don't tell the whole story (p. 6).</li>
            </ul>
            <p>Senge (2006) also points out that in complex environments, cause and effect are often separated by long delays or happen in different areas. A change in one area might not show an impact until much later, or it might circle back and affect the original source in a "feedback loop". In our course reading, we see that "everything is connected to something else" (Holt, 2019). While a linear thinker might see a car as just an engine and a chassis, a systems thinker sees that car as a participant in a huge transport network—interacting with smart roads, satellites, and even environmental laws.</p>
            
            <h3>Categorizing the Systems We Build</h3>
            <p>To apply systems thinking effectively, we have to recognize that not all systems are built the same way. Peter Checkland developed a taxonomy that helps us organize these different types (Holt, 2019):</p>
            <ul>
               <li><strong>1. Natural Systems:</strong> These are systems beyond our control, like weather or biological environments.</li>
               <li><strong>2. Designed Physical Systems:</strong> These are the physical systems and hardware we create, like smartphones or spacecraft.</li>
               <li><strong>3. Designed Abstract Systems:</strong> These are non-physical, like mathematical models, equations, or even thought experiments.</li>
               <li><strong>4. Human Activity Systems:</strong> These consist of people interacting to achieve a goal, like a political group or a business organization.</li>
               <li><strong>5. Transcendental Systems:</strong> These are systems that go beyond our current understanding.</li>
            </ul>
            <p>In the digital world, systems typically fit into multiple categories at once (Holt, 2019). Having completed my Google UX Design Professional Certificate, I've learned how vital the "Human Activity" piece is to a technical system. Systems thinking lets us bridge these categories to make sure the software concept (Abstract) actually works in the physical reality for the people (Human Activity) who need it. It's about realizing that a perfectly coded app is useless if the people using it don't understand the interface. My UX background has taught me that we have to design for the human element as part of the system, not as an afterthought.</p>
            
            <h3>The "Three Evils" of Engineering</h3>
            <p>The reason we need a systems-thinking approach is because it is very easy for things to go wrong. In real-world projects, unmanaged complexity can lead to total failure. Jon Holt (2019) identifies what he calls the "Three Evils of Systems Engineering"</p>
            <ul>
               <li><strong>Complexity:</strong> This happens when we don't identify where the complexity is, which means we can't manage or control it. There are two types: Essential Complexity (natural to the system) and Accidental Complexity (caused by bad processes or tools).</li>
               <li><strong>Communication:</strong> This is where information flow fails or becomes ambiguous. With so many different technical backgrounds on a project, miscommunication is a huge risk.</li>
               <li><strong>Understanding:</strong> This is where different points of view (contexts) are ignored and people start making assumptions.</li>
            </ul>
            <p>These "evils" feed into one another. If you have unmanaged complexity, your communication will probably fail, which leads to a lack of understanding among the team (Holt, 2019). Systems thinking helps us troubleshoot these issues by forcing us to define boundaries and identify exactly who the stakeholders are and what they need.</p>
            
            <h3>Characteristics and Boundaries of a System</h3>
            <p>Every system has a structure made up of System Elements that interact (Holt, 2019). These interactions create Interfaces, which are the points where different parts of a system meet to exchange information or materials. If you don't define your interfaces correctly, your system will fail during integration. We also track Attributes, which are the properties like dimensions, weight, or data structures that define what the system "is" (Holt, 2019). Meadows (2008) notes that the most important part of a system is often its "function or purpose," and the attributes must all serve that goal.</p>
            <p>A practical part of systems thinking is defining the Boundary. The boundary explains the scope—what is inside the system and what is outside (Holt, 2019). In digital environments, this isn't always a physical wall; it can be conceptual, like the link between a car and a satellite. Inside the boundary, you have your system elements. Outside, you have your Stakeholders and Enabling Systems (Holt, 2019). Understanding these interfaces is crucial because failures usually happen at the points where different parts of a system meet.</p>

            <h3>Why MBSE is Applicable in Complex Digital Systems</h3>
            <p>As digital systems grow in complexity, traditional "document-based" engineering just doesn't cut it anymore. When you have knowledge scattered across Word documents or spreadsheets, it's nearly impossible to ensure that a change in one requirement doesn't break a design element buried in a different file. Model-Based Systems Engineering (MBSE) is a rigorous approach that moves the "single source of truth" from a pile of static documents to a dynamic digital model (Holt, 2019).</p>
            <ol>
               <li><strong>1. Managing Complexity through Abstraction:</strong> A Model is a simplified representation of a system designed to capture the information needed to build it successfully. It doesn't need to show everything—just enough to get the job done (Holt, 2019). MBSE helps us focus on the essential parts while stripping away the noise. By using different "views," we can see exactly where the complexity lives.</li>
               <li><strong>2. Bridging the Communication Gap:</strong> In any big project, you have software engineers, managers, and customers all speaking different "dialects." MBSE addresses this by establishing a Common Language. This includes a "Spoken Language" like SysML and a "Domain-Specific Language" called an Ontology (Holt, 2019). This ensures that when a stakeholder looks at a model, they see information tailored to their specific "context" while remaining consistent with the rest of the project.</li>
               <li><strong>3. Rigorous Consistency and Behavior Modeling:</strong> In a digital system, the structure (what it is) and the behavior (how it acts) have to be perfectly aligned. MBSE ensures this consistency. If a sequence diagram shows a message being sent, the structural diagrams have to show an interface that allows it to happen (Holt, 2019). This rigor allows us to model "rainy day" scenarios—where we troubleshoot what happens when things go wrong—before we ever build a physical prototype.</li>
            </ol>

            <h3>The Mantra: People, Process, and Tools</h3>
            <p>Success in this field isn't just about the software; it's about the "Systems Engineering Mantra": People, Process, and Tools (Holt, 2019).</p>
            <ul>
               <li><strong>People:</strong> It's about the competence of the team. They need the right skills and attitude to enable the approach.</li>
               <li><strong>Process:</strong> This is the overall ability of the organization to carry out tasks effectively. It's the "what" and "how" of the work.</li>
               <li><strong>Tools:</strong> This is the software and resources that help the people do the work.</li>
            </ul>
            <p>A huge systems-thinking insight here is that the process must drive the choice of tools, rather than letting the tools dictate how we work (Holt, 2019). Senge (2006) would likely describe this as a "mental model" shift—we have to change how we think about the work before the tools can have any real impact.</p>

            <h3>Needs, Requirements, and Constraints</h3>
            <p>Every system exists for a purpose, and we express that through needs. These can be broken down into Requirements (what it must do), Features (collections of functions), and Goals (high-level purpose) (Holt, 2019). However, we also have to deal with constraints. Constraints limit how we can build the system—they might be environmental, safety-related, or based on quality standards. Systems thinking helps us see how these constraints interact with our requirements. For example, a safety constraint might make it impossible to meet a specific speed requirement. Finding that out early in a model saves time and money (Holt, 2019).</p>

            <h3>The Evolution Toward Maturity</h3>
            <p>Moving from a document-based setup to a model-based one is a journey. Jon Holt (2019) describes five stages of evolution:</p>
            <ol>
               <li><strong>Stage 1: Document-Based:</strong> Knowledge is scattered across independent files.</li>
               <li><strong>Stage 2: Document-Centric:</strong> Some notations are used, but they are just "pictures" that don't own any data.</li>
               <li><strong>Stage 3: Model-Enhanced:</strong> A true model starts to emerge and own some of the system knowledge.</li>
               <li><strong>Stage 4: Model-Centric:</strong> The model is nearly complete and owns most of the knowledge.</li>
               <li><strong>Stage 5: Model-Based:</strong> The model is a standalone entity that holds all the system data. Documents are just views generated from the model.</li>
            </ol>
            <p>Most organizations are somewhere in the middle of this growth process. It takes a growth mindset to move through these stages and realize that the model is the "single source of truth." By Stage 5, the model allows for automated checks and seamless integration between different tools.</p>

            <h3>Final Reflection</h3>
            <p>Embracing a model-based approach is about more than just using new tools; it's a shift in mindset. As we look toward 2035, the entire industry is heading toward a fully MBSE environment (Holt, 2019). By using systems thinking and my background in UX design, I'm learning to stop building isolated "parts" and start engineering successful, resilient systems that actually survive in our connected world.</p>
            <p>It's been a challenge to balance my classes and work lately, but I'm really motivated by these concepts because they show how a focused, technical approach can solve massive problems. I've always been a self-starter and a quick learner, and diving into the "Single Source of Truth" philosophy makes so much sense to me. I'm looking forward to applying these ideas as I dive deeper into IT 312 and my own projects!</p>

            <footer class="article-footer">
                <h3>Sources:</h3>
                <ol>
                    <li>Holt, J. (2019). <em>Systems Engineering Demystified</em>. Packt Publishing.</li>
                    <li>Meadows, D. (2008). <em>Thinking in Systems</em>. Earthscan. <a href="https://research.fit.edu/media/site-specific/researchfitedu/coast-climate-adaptation-library/climate-communications/psychology-amp-behavior/Meadows-2008.-Thinking-in-Systems.pdf">https://research.fit.edu/media/site-specific/researchfitedu/coast-climate-adaptation-library/climate-communications/psychology-amp-behavior/Meadows-2008.-Thinking-in-Systems.pdf</a></li>
                    <li>Senge, P. (2006). <em>The Fifth Discipline</em>. Doubleday. <a href="https://www.e-education.psu.edu/geog468/sites/www.e-education.psu.edu.geog468/files/TheFifth%20Discipline.pdf">https://www.e-education.psu.edu/geog468/sites/www.e-education.psu.edu.geog468/files/TheFifth%20Discipline.pdf</a></li>
                    </ol>
            </footer>
         </article>

         <!-- Module 1.2 Blog Post Starts here -->
          <article>
            <header class="article-header">
               <h2>Module 1.2 Blog Post</h2>
            </header>
            <h3>Systems Development Life Cycle</h3>
            <p>Hi everyone! Im back for my second post in IT 312. After our deep dive into systems thinking last time, we're moving into something that feels practical for anyone building or managing digital environments: the Systems Development Life Cycle (SDLC). We've been reading through chapters three, four, and five of Systems Engineering Demystified (Holt, 2019), and it's honestly changed how I look at my own projects, like the cost and risk modeler I'm building on GitHub.</p>
            <p>When we think about a system, it's easy to just focus on the "cool" part—the actual building or the code. If we don't have a plan for how that system is going to be supported or retired, we're just creating a wasteful situation down the road.</p>

            <h3>Defining the Life Cycle</h3>
            <p>The Systems Development Life Cycle is essentially the life story of a system. It's the roadmap that takes an idea from a simple "What if?" all the way to the moment it's finally turned off and replaced. It isn't just a technical checklist; it's a way to manage the "Three Evils" we talked about last time—Complexity, Communication, and Understanding.</p>
            <p>According to Jon Holt (2019), a life cycle is a way to partition the life of a system into manageable chunks called stages. These stages give us a foundation to make sure we are actually meeting the needs of the stakeholders at every point in time. If you don't think in terms of a life cycle, you're basically just winging it, and that's how airplanes fall out of the sky or IT systems bring companies to their knees.</p>
            <p>The standard life cycle typically includes several key stages (Holt, 2019):</p>
            <ul>
               <li><strong>Conception:</strong> Where the initial idea is born.</li>
               <li><strong>Development:</strong> Where the system is actually designed and built.</li>
               <li><strong>Production:</strong> Where we make copies or deploy the system for real-world use.</li>
               <li><strong>Utilization:</strong> Where the system is actually doing its job.</li>
               <li><strong>Support:</strong> Where we troubleshoot and maintain the system.</li>
               <li><strong>Retirement:</strong> Where the system is phased out.</li>
            </ul>

            <h3>Systems and Interfaces</h3>
            <p>Before we dive into the models, we have to talk about how these systems are actually put together. Building on what I said in my last post about systems thinking being the “connective tissue” of a project, Chapter 3 takes that even further by looking at the actual physical and technical connective tissue: the interfaces. An interface is the boundary where two system elements meet to exchange information or materials.</p>
            <p>If we don't define these interfaces during the development stage, we end up with what I call the "Inedible System" problem. In a letter I helped my grandparents write to a chef, I mentioned that if vegetables in a soup are cut too large, they are impossible to eat with any dignity. Interfaces are the same. If they aren't defined into "bite-size" pieces that follow a clear protocol, the data can't "flow," and the system becomes a mess of gristly, unworkable parts. Thinking about the life cycle means designing these interfaces so they work not just today but five years from now during the utilization stage.</p>

            <h3>Comparing Life Cycle Models: Linear, Iterative, and Incremental</h3>
            <p>Not every project should follow the same path. Depending on what you're building, you might choose a different life cycle model. Holt (2019) breaks these down into three main types, and they each have their own pros and cons.</p>

            <h4>1. Linear Models</h4>
            <p>The linear model is the straight line of systems engineering. You do one stage, finish it completely, and then move to the next. It's very logical and easy to explain to people who aren't technical.</p>
            <ul>
               <li><strong>Characteristics:</strong> Every stage has a clear start and end point. You don't move forward until the previous stage is perfect.</li>
               <li><strong>Advantages:</strong> It's great for projects where the requirements are set in stone and aren't going to change. It feels very stable and organized.</li>
               <li><strong>Potential Drawbacks:</strong> This is where things can get "inedible." If you wait until the very end to show the customer stakeholder the system, and it's not what they wanted, you've wasted a massive amount of time and money. According to the NASA Systems Engineering Handbook (2016), linear models are often criticized because they don't allow for the rework that usually happens when people realize they missed a requirement halfway through. If you can't backtrack easily, you're stuck with a "woody peach" of a system—it looks okay on the outside, but it's unusable.</li>
            </ul>

            <h4>2. Iterative Models</h4>
            <p>Iterative models are all about the growth mindset. Instead of trying to get it perfect in one go, you go through cycles. Each cycle (or iteration) gets you closer to the final goal.</p>
            <ul>
               <li><strong>Characteristics:</strong> You repeat the development processes over and over, refining the system each time based on what you learned in the last cycle.</li>
               <li><strong>Advantages:</strong> It's excellent for troubleshooting. You find mistakes early because you're constantly reviewing the model. It allows for a lot of flexibility if the requirements shift.</li>
               <li><strong>Potential Drawbacks:</strong> It can feel like you're overthinking the project if you aren't careful. Without a clear process to drive the iterations, you might just keep going in circles without ever actually finishing. It requires a lot of discipline to know when a version is good enough for that cycle.</li>
            </ul>

            <h4>3. Incremental Models</h4>
            <p>Incremental models are about getting results fast. You break the system into chunks and deliver them one by one. I think this approach has advantages because it means the user gets to use part of the system while you're still building the rest.</p>
            <ul>
               <li><strong>Characteristics:</strong> Each increment is a functional piece of the system. You build the foundation first, then add the features.</li>
               <li><strong>Advantages:</strong> It reduces waste because the customer can see progress right away. As the Department of Defense Systems Engineering Guidebook (2024) explains, this incremental approach is the preferred method for modern digital systems because it allows us to provide capabilities to the user early and often while managing risks in smaller, more manageable pieces.</li>
               <li><strong>Potential Drawbacks:</strong> The integration can get messy. If you don't have a solid architecture or ontology from the start, the different increments might not talk to each other correctly when you try to integrate them at the end.</li>
            </ul>

            <h3>Deep Dive: The V-Model and Technical Management</h3>
            <p>One concept from the reading that really stuck with me is the V-model. It's a way to visualize how we move from high-level requirements down to detailed design and then back up through testing and verification (Holt, 2019). The left side of the V is where we define what we want, and the right side is where we check to make sure we actually built it right.</p>
            <p>This is where the Technical Management Processes from Chapter 5 come in. To keep a project from spiraling out of control, we have to use processes like:</p>
            <ul>
               <li><strong>Risk Management:</strong> Identifying potential problems early.</li>
               <li><strong>Configuration Management:</strong> Making sure we know exactly which version of the model we are working on so we don't have a communication failure.</li>
               <li><strong>Information Management:</strong> Ensuring that the right people have the right data at the right time.</li>
               <li><strong>Agreement Processes:</strong> These are the supply and acquisition processes (Holt, 2019). They make sure that when we buy a component or a service, we actually get what we paid for.</li>
            </ul>
            <p>If we don't have these processes in place, our life cycle is just a series of accidents. I've realized that failing to document a technical issue properly means the next person has to repeat the entire troubleshooting process from scratch. That is a total waste of time and energy (Holt, 2019).</p>

            <h3>Why Life Cycle Thinking is Critical for Digital Systems</h3>
            <p>Reflecting on all this, I've realized that thinking in terms of a life cycle is the only way to ensure sustainability and evolution. In IT, we often get caught up in the deployment phase, but we forget about the retirement or support phases.</p>
            
            <h4>1. Design and Sustainability</h4>
            <p>If we don't plan for the support stage during the development stage, the system is going to be a nightmare to maintain. This is exactly what I mean when I talk about attention to detail. Digital systems are the same way. If you don't cut your code or your hardware interfaces correctly during the design phase, the support team is going to struggle to fix it later. Sustainability means the system can keep running without being a drain on resources.</p>
            
            <h4>2. Evolution and the Single Source of Truth</h4>
            <p>Digital systems are never truly finished. They have to evolve. By using Model-Based Systems Engineering (MBSE) within our life cycle, our model becomes the single source of truth that allows us to see how a change in 2026 might impact the system in 2030 (Holt, 2019). This helps us avoid accidental complexity that comes from patching old systems without understanding the original design.</p>

            <h4>3. Retirement: Avoiding the Wasteful End</h4>
            <p>One of my biggest pet peeves is waste. In the system life cycle, waste happens when we don't plan for the end of a process. The retirement stage is where we figure out how to transition data and hardware responsibly. If we don't plan for retirement, we end up with zombie systems that are insecure and just take up space and power without providing any real value.</p>

            <h3>My Reflection: The People, Process, Tools Mantra</h3>
            <p>Success in IT 312 isn't just about knowing the definitions; it's about seeing how they all link together. I've learned that whether I'm developing a complex satellite model or tackling a new technical challenge, I have to follow a process. The life cycle models give us that process.</p>
            <p>I'm a self-starter, and I love a challenge, but I also know that I have to balance my credit load with my work hours. Thinking in terms of a life cycle for my own time management has helped me stop leaving things to the last day. I'm motivated to keep closing my knowledge gaps in IT and cybersecurity, and I think understanding these life cycle models is going to be a huge part of my growth.</p>

            <footer class="article-footer">
                <h3>References:</h3>
                <ol>
                    <li>Hirshorn, S. (2007). <em>NASA Systems Engineering Handbook</em>. <a href="https://www.nasa.gov/wp-content/uploads/2018/09/nasa_systems_engineering_handbook_0.pdf">https://www.nasa.gov/wp-content/uploads/2018/09/nasa_systems_engineering_handbook_0.pdf</a></li>
                    <li>Holt, J. (2019). <em>Systems engineering demystified</em> (2nd ed.). Packt Publishing.</li>
                    <li>Office of the Under Secretary of Defense for Research and Engineering. (2022). <em>Systems Engineering Guidebook</em>. <a href="https://www.dau.edu/sites/default/files/Migrated/CopDocuments/Systems-Eng-Guidebook%20Feb2022-Cleared.pdf">https://www.dau.edu/sites/default/files/Migrated/CopDocuments/Systems-Eng-Guidebook%20Feb2022-Cleared.pdf</a></li>
                </ol>
            </footer>
         </article>

         <!-- Module 2.1 Blog Post Starts here -->

         <!-- Module 2.2 Blog Post Starts here -->

         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
      <footer class="page-footer">
       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>