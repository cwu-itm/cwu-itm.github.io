<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Sean Henderson | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>
         <!-- Module 1.1 Blog Post Starts Here-->
         <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>
            <h3>What Systems Thinking is:</h3>
            <p>Systems Thinking is the thought process that comes with Systems Engineering, so to define Systems Thinking we must first define Systems Engineering, Systems Engineering Demystified defines Systems Engineering in its first pages rather succinctly as “The realization of successful systems” (Holt, 2023). Using this definition, we can extrapolate the definition of Systems Thinking as ‘The imagination and designing of systems’ the simplicity grants the width that is needed to truly define Systems Thinking. Where systems engineering is the process of making a functional system, system thinking is the thought process that encourages the creation of successful systems. </p>
            <h3>How Systems Thinking is different:</h3>
            <p>Where more traditional problem solving methods focus more heavily on the problem and the direct causes, System Thinking looks at the entire architecture of a situation instead of breaking it up into sections. An example would be if you take a vehicle like a car take it apart and look at each part individually, that would be an example of more traditional ways of looking at issues, a focus on parts and not the whole. Systems Thinking instead would look at the car as a whole unit, how it functions and what it does, it would analyze where problem points are in the entire care not just for individual faults in parts. “Systems Thinkers have taught us that a system is a product of the interaction of its parts, not just the sum of its parts.” (Dowdall, 2019) is the summarization of what the root difference that Systems Thinking represents from other methods of viewing the world.</p>
            <h3>What is Model Based Systems Engineering:</h3>
            <p>The Model Based Approach of Systems Engineering is as the ‘of’ indicates a method of performing Systems Engineering by using models, “a simplified abstraction of something--a graphical, mathematical, or physical representation that abstracts reality to eliminate some complexity.” (Nataliya, 2020). Using models when engineering systems makes understanding complex systems easier for the people making them, making the overall system more coherent. The model system does not just make creation easier, it also makes communicating function easier by enabling the creation of ‘views’, which are collections of information relevant to the different stakeholders of a system, a stakeholder is a person or organization that has an interest (or stake) in the system. With these ideas in mind, good use cases for Model Based Systems Engineering would be when a system needs to be designed with high complexity while also needing to be understood by those not directly involved with the creation of the system in question.</p>
            <p>Model Based Systems Engineering as a concept is broken down into three major chunks, Approach, Goal, and Visualization, Holt provides a great summary of each facet in Systems Engineering Demystified (2023). Approach involves firstly the Framework, which defines the structure, content, and consistency of the information put into the Model. The Framework is informed by the Process Set which is where the ‘where’ of the information is determined. The Frameworks content is determined by Viewpoint and Ontology, Viewpoint is a set of answers determined when View is determined, who is interested, why they are interested, and what information are the three big parts of a Viewpoint. Goal is the next section of Model Based System Engineering, made up of View, Model, and System, View is the data itself that informs the Model and the Diagram through the answering of the questions from Viewpoint. 
               The Model part is all Views compiled into a cohesive whole, an overview if you want to be funny about it. The System section is the end product what the entire process is working to create. Visualization is the last major chunk, made up of Notation and Diagram. Notation is the language used to communicate information, be it written or illustrated. Diagram is the application of Notation into a communication medium, a document or picture itself. There are a couple more sections attached to these three main chunks, but they are parts that are either used to create (Tools) or parts that ensure things are how they should be (Best Practices).</p>
            <h3>Complex Digital Systems and Model Based Approach:</h3>
            <p>All of that information is necessary to understand how Model Based System Engineering can be used to build digital systems of high complexity. Much in the same way that Model Based System Engineering can be used to map out a city wide bus network, it can be used to abstract a digital system in a way that is more understandable than the raw code and files that would exist otherwise. To illustrate why a Model Based Approach is useful we will compare it with an approach on the opposite side of the thought process, a Document Based Approach. Lets take the bus network idea, with documents the system design will be mostly made of typed information and spreadsheets of numbers. While this is functional there are issues of relevant data being lost in a pile of unrelated documents which can slow down the overall project and make the end result worse when implementing it into physical use in an actual city.
                Applying this to the creation of a digital system would make it all worse, the only people able to understand each part of the system being made would be the ones actively working on the sections in question, backend developers understanding the code but not the user interface, frontend developers understanding the user interface but not the code that makes it function correctly. It would create a kluged together mess that would function but not as efficiently as it would if it was created with more clarity of vision shared between the various team members. On the other hand, if a Model Based Approach was used there would be maps and physical models made of the city that the bus route is being designed for, this would grant the ability for each team member to convey ideas for bus stop placement and so that the possible traffic issues that routes could have would be seen a bit easier.
                 By applying this to the digital there would be mockups of what the end result should look like so that everyone on the team has an idea of what they are working towards. There would also be lists of what different user groups (Stakeholders) might be expecting to find within the project, an example would be that advertisers would expect places set aside for their ads to be displayed, users would be looking for the ads in question to be non-invasive. A Model Based Approach would make balancing all of the expectations more manageable for a design team and make the end product more put together and coherent in the end.</p>
            <footer class="article-footer">
                <h3>Sources:</h3>
                  <ol>Holt, J (2023). <em>Systems Engineering Demystified</em>. Packt Publishing Ltd.</ol>
                  <ol>Dowdall, J. (2019, July 3). <em>Systems Thinking examples: Learn how to apply by Catalyst Consulting</em>. Catalyst Consulting. <a href="https://www.catalystconsulting.co.uk/systems-thinking-examples/">https://www.catalystconsulting.co.uk/systems-thinking-examples/</a></ol>
                  <ol>Nataliya, S. (2020, December 21). <em>An Introduction to Model-Based Systems Engineering (MBSE)</em>. <a href="https://www.sei.cmu.edu/blog/introduction-model-based-systems-engineering-mbse/">https://www.sei.cmu.edu/blog/introduction-model-based-systems-engineering-mbse/</a></ol>
            </footer>
         </article>

         <!-- Module 1.2 Blog Post Starts here -->
          <article>
            <header class="article-header">
               <h2>Module 1.2 Blog Post</h2>
            </header>
            <h3>What is the Systems Development Life Cycle?</h3>
            <p>To understand the specifics of the systems development life cycle, first we need to define what a life cycle is in the first place. Holt gives a short but sweet definition for life cycles in his book, Systems Engineering Demystified, as “Any number of Life Cycles describes the 
               evolution of one or more Entities over time.” (2023). When it comes to systems development life cycles the entity in that definition is a system, a remarkably clean definition. Everything that changes can be represented by a life cycle model, the production line of a car to the 
               development of a computer program can all have life cycle models applied. Of course, to understand what that means we need to know what life cycles and their models are made of, which is what the next section is about.</p>

            <h3>Life Cycle Characteristics</h3>
            <p>A traditional life cycle is made up of six distinct stages, conception, development, production, utilization, support, and retirement.  The first stage, conception, is where a plan is made the ‘what’ effectively, what is the end result going to be, what groups or stakeholders as 
               defined in the last blog post will be interested in the end product, and finally what will be needed to achieve the end result. A big stage overall but only sets up for the next couple of stages, for instance, development which is the next stage is concerned with coming up with 
               options to achieve the end goal desired while satisfying the requirements put upon the project by restrictions and stakeholders. The last thing that development does is choose the best option generated, an example of option would be several different designs were created for a 
               future car all fulfilling the requirements put out by the conception stage but with minor variations between them, aesthetics, maintainability, and performance could all have slight differences between the variants come up with, one of these would be chosen to move forward to the 
               next stage. The third stage is production, which is rather simple compared to the last two as it mostly focuses on the creation of the preferred option as well as the validation of system and verification that it was built to the specifics set down in the conception and development 
               stages.</p>
            <p>The fourth stage, utilization, is the first one where stakeholders not directly involved with the creation of the system/product get to handle said system/product, the people buying cars or subscribing to a service for instance. Stage five runs in parallel with the fourth, it is 
               designated as support. The support stage is concerned with everything that a system/product might need long term, maintenance, bug fixing, error reporting, and customer support services would all fall under this stage. The last stage and the one with the most finality to it is 
               retirement, this is the process that needs to be taken to decommission a system/product and dispose of the remains safety. A good example of retirement is nuclear waste, something that most people would agree is rather unsafe, but through proper processing procedures can be rendered 
               into an easily storable form that, when isolated, is harmless. All of these stages are gone over in Jon Holts Systems Engineering Demystified (2023) so if more detail is desired on these parts specifically that book would be a good place to start.</p>
               
            <h3>Key Characteristics and Model Types</h3>
            <p>All of the stages are important, but they can be case specific in what they do occasionally. Something that does not change as often is the overall methodology of the life cycle model; there are three types of life cycle model as defined by the U.S. Department of Transportation in 
               their Systems Engineering for ITS article (2022). The first type identified by the DoT is the sequential method (or linear method if you are referring to the Systems Engineering Demystified) also called the waterfall method, this method’s primary feature is that it goes step by step 
               one after the other. This method is most effective when sudden changes are unlikely to occur, for instance if there is a well-planned project that is being handled by an individual or a small team the sequential method will work best. The next method is called the iterative method 
               which involves effectively repeating the first three stages multiple times, allowing for the development of a larger project as a set of smaller ones. An example is if a car is being designed but with iterative method first, the engine would be designed and an initial production run 
               done for testing, then the frame would be designed around the engine and both together would be tested, then finally a final pass would be done to make the car a finalized product and then released for general sale. The last method called incremental, has the concept be made to 
               cover the entire issue then develops, produces and then utilizes multiple times to cover the end goal in piecemeal. This allows for a more rapid rollout for an initial solution that can cover the most vital pieces of a project while allowing for updates to be made when more pieces 
               of the ‘puzzle’ are made to finish up.</p>

            <h3>Advantages and Disadvantages of the Life Cycle Methods</h3>
            <p>While some advantages were pointed out for the various methods it was to help understand why they exist in the first place, not to make one seem better than the others. The big advantage of the linear method is that it allows for easy following and step-by-step development of a 
               project. On the other hand, the big downside of the linear method is that any changes to the requirements or any of the steps will demand a total restart of the project to the affected step or even send the project back to the conceptual phase. My initial example of a small project 
               that is unlikely to change is likely as far as this method can truly reach, however just because this is small in grasp does not mean it is useless as a method. The next method, iterative, has a big advantage of being able to fine tune the requirements it works under due to the 
               revisiting it does to the concept stage and makes tweaks to the entire structure multiple times. The downside of this is that it effectively is just a systemization of the big flaw in the linear method, any changes to the requirements sends the project back to the start but a bit 
               lessened because the initial work is made with the iteration in mind so all work done can be done with some future proofing in mind. The last of the three methods, incremental, big advantage is that it makes a whole solution at the start and completes it in pieces so if a change is 
               made in the future, not yet done section it can be accounted for and tacked on to the project. On the downside, if a change needs to be made in an earlier more foundation part of the project, like in a piece of code that a lot of the future sections rely on or refer to, it can throw 
               everything into utter chaos by forcing the tweaking of everything already done.</p>

            <h3>Why this is Important for Digital Systems</h3>
            <p>The use cases for life cycle models in the digital realm are much the same for why they are useful when it comes to plotting a project in the physical world, it grants structure to projects and allows for goals to be set. 
               “Movement between stages represents a decision point with specific criteria related to stage entry and exit.” (SEBoK, 2025) the ability to give definitive start and end points for sections of projects can make the overall development easier and make moral of the team working on the 
               project more easily sustained. A example of a digital project that is failing to adhere to a life cycle model is a video game in something called ‘development hell’ which means that is stuck in a certain phase of its creation, it could be a physics bug that the developers cannot find a fix 
               for and have been beating their heads against for months or just executives changing the core concept without regard for the games current completion, forcing a creative restart. Both of those things have happened for anticipated games and the end result, if it was not cancelled, was nearly 
               always a disappointment. Of course, the opposite can happen as well, the stages are adhered to closely and a game is made that is a hit, with a coherent and well-built concept that anticipated everything the development would need but also left room to loop back for refinement once initial 
               release has happened. Games like those are called live service and they have proven to be massively profitable, World of Warcraft (2004) and Destiny 2 (2019) were or are live service games that stayed popular for years and still maintain dedicated players to the current day.</p>

            <footer class="article-footer">
                <h3>Sources:</h3>
                  <ol>Holt, J (2023). <em>Systems Engineering Demystified</em>. Packt Publishing Ltd.</ol>
                  <ol><em>Systems Engineering for ITS. </em>(2022). Dot.gov <a href="https://ops.fhwa.dot.gov/seits/sections/section2/2_7.html">https://ops.fhwa.dot.gov/seits/sections/section2/2_7.html</a></ol>
                  <ol>SEBoK. (2025, October 26). <em>Life Cycle Models - SEBoK</em>. SEBoK.<a href="https://sebokwiki.org/wiki/Life_Cycle_Models">https://sebokwiki.org/wiki/Life_Cycle_Models</a></ol>
            </footer>
         </article>


         <!-- Module 2.1 Blog Post Starts here -->
          <article>
            <header class="article-header">
               <h2>Module 2.1 Blog Post</h2>
            </header>
            <h3>What is Human-Centered Design?</h3>
            <p>Human-centered design is a rather simple concept when taken in a zoomed-out perspective, it is the rather novel idea of creating things that are built around what people need instead of what a corporate entity thinks they need. Harvard Business School puts human-centered design in a similar 
               way “a problem-solving technique that puts real people at the center of the development process” (Landry, 2020). Examples of human-centered design are many including the digital sphere, the first of which is Spotify which has features like a discover weekly music album that is shuffled for 
               its users automatically as well as a more experimental and rough artificial intelligence that selects a theme and provides that to the user, its not perfect but it is a step in the right direction for embracing human-centered design more closely. Another digital application that represents 
               the idea of building around people is Venmo, an app that enables the easy exchange of money, it allows for splitting of payments between groups which enables paying for large bills to be split easily. Human-centered design is just about building user interfaces and experiences that are easy 
               to understand and adapt to, instead of having to teach someone a system, the system in question abides by the average expectations of a person and can be learned independently.</p>
            <h3>Different Perspectives</h3>
            <p>Something as simple as human-centered design has several different views surrounding it on how its objectives can be achieved. One of the oldest perspectives is that of ISO 9231-210 made in 1999 it established the basic ideas of human-centered design and set one of the first 
               standards for interactive systems. The ISO standard established that to get anywhere with human-centered design there needs to be a comprehensive knowledge of what the potential users of a system or application are going to want from the system or application. This is simple in 
               theory but complex in execution, as all good standards are, because it demands that a very widespread team be made that can account for as many desires as possible while keeping the end goal in sight and creating a coherent user experience. 9231 maps out six steps to its methods, 
               the first of which is to plan the human-centered design process, this is where how much effort will be put into the design process. The second step is to determine to context and environment the design is expected to exist within, this will inform the specific needs of the end 
               design. The third step is figuring out what the users will want in the end, this needs to be subject to change as the potential userbase expands or contracts. The fourth step is actually create possible solutions that can match all of the requirements and hold up to the next step. 
               Which is evaluation, this is when the solution made in step four is interrogated and picked apart for flaws, if it fails the process loops back and a new design solution is made, if it succeeds it gets to be pushed forward as a proper solution.</p>
            <p>However, ISO-9231 is not a monolith, there are variants and expansions of its ideas everywhere. One of these is explained in an IDEO field guide which maps out a three-part process to building a human-centered design. The three steps are rather simple, the first is Inspiration 
               “learn how to better understand people” the second is Ideation “generate tons of ideas, identify opportunities for design, and test and refine your solutions” the third and last is Implementation “get your idea to market and how to maximize its impact in the world” (IDEO, 2015). 
               There are some obvious differences between the two, the amount of steps being the big one, however there is a good underlying similarity between both methods. Both preach that iteration and testing is an important part of the overall system, the IDEO method can in that light be seen 
               as a refinement and simplification of the 9231 methods.</p>
            <h3>How Perception Affects Usability</h3>
            <p>How people see things affects everything they do, it colors their opinions of others, it can make someone think a dish they would love is disgusting if it looks wrong to them, and it can make user interfaces more or less usable depending on how it is seen. Designing with the Mind in 
               Mind puts how perception can be shifted in a good way, “Our perceptions are heavily biased by at least three factors: The past: our experience The present: the current context The future: our goals” (Johnson, 2021). An example of how those three factors can influence perception is, 
               for the past, if a user experience has a very radical setup that is unlike anything that a user has seen before it can lead to a bad level of usability. This is even a problem for common applications like Microsoft Word, if you introduce someone who is only familiar with writing 
               letters by hand and have no experience with using a keyboard they will struggle to adapt to typing on a computer due to a double layer of no experience, the first is the keyboard but the second is that a person will have no idea what to do with the fairly data dense user interface 
               of Word. They may be able to figure out the basics of typing, but the changing of font type and document design might not come naturally. Examples of issues that can come up due to the present is that if an application has a weird layout that can make a user think it can do something 
               it cannot, an application that comes to mind is the Fred Meyer mobile website, it has some of the functionality of the mobile app but it lacks a few key features that make it nearly impossible to use well while in the store. The last part is goals or the future if you want to stay on 
               theme, an example of this can be found in the first example, the new typist, if they need to get good at typing for some reason, they need to be able to write emails or reports quickly for a job, they may make an effort to improve their typing ability and learn the ins and outs of 
               Microsoft word by experimenting and asking for guidance. </p>
            <p>There are also four laws that can help the issues of perception, give guidelines for how things should be done and not done. The first of these laws is Jakob’s law, which involves something familiar, expectations “the tendency for users to develop an expectation of design conventions based on their cumulative experience from other 
               websites” (Yablonski, 2024). Jakob’s law is just a formalization of the previous paragraphs past section; by putting it done as a law it is granted a gravitas and ideological weight that would be missing otherwise. The second law is Fitts’s law, which can be traced back to 1954 and it makes 
               the amount of time to rapidly move a cursor to a target area is a mathematical formula, the theory has not been proven wrong since and is still deeply important to ergonomic and computer interaction. While not directly related to how perception can be harnessed, Fitts’s law gives a baseline 
               idea for organizing things so that users can still get things done quickly, and at this point in time it is so deeply integrated into the background expectations of the public that an application that fails to take Fitts’s into consideration will seem wrong. The third law being listed is 
               Miller’s law, which effectively looks at the limit of how many chunks of information the average person can remember at a given time. Yablonski defines chunks of information as a “collection of basic familiar units that have been grouped together and stored in a person’s memory” (2024). 
               Miller’s law marks out that people can only remember seven plus or minus two chunks of information at any one time. This limits how much information can be thrown at people all at once because anything past the upper limit is likely to become cognitive noise in its entirety. The last law is 
               Hick’s law, which is all about decision time. Hick’s law mathematically formalized the relationship between number of choices and decision time. This is important because it makes the creation of interfaces and systems that may depend on faster choices and be able to optimize their menus for 
               a balance between speed and usefulness. All of the laws used together can be glued together to make an idea of what a good human centered design needs but using them to augment the understanding that is already present in ISO and IDEO systems can bring all of them to a new level of 
               understanding and usability.</p>

            <footer class="article-footer">
               <h3>Sources:</h3>
                  <ol>Landry, L. (2020, December 15). <em>What is human-centered design?</em> Business Insights Blog; Harvard Business School Online. <a href="https://online.hbs.edu/blog/post/what-is-human-centered-design">https://online.hbs.edu/blog/post/what-is-human-centered-design</a></ol>
                  <ol>IDEO. (2015). <em>The Field Guide to human-centered design.</em> (1st ed.). Design Kit.</ol>
                  <ol>Johnson, J. (2021). <em>Designing with the mind in mind : simple guide to understanding user interface design guidelines</em> (Third edition.). Morgan Kaufmann Publishers.</ol>
                  <ol>Yablonski, J. (2024). <em>Laws of UX</em> (2nd ed.). O'Reilly Media, Inc.</ol>
            </footer>
          </article>

         <!-- Module 2.2 Blog Post Starts here -->
          <article>
            <header class="article-header">
               <h2>Module 2.2 Blog Post</h2>
            </header>
            <h3>What are Memory and Mental Models?</h3>
            <p>This may seem like a simple question, but a definitive answer must be defined so that this post can have a stable ground floor to operate from when it comes to definitions and the conceptual understanding. With this in mind I will be pulling my definition for what memory is 
               from Designing with the Mind in Mind, with a paraphrased summary of how the book describes it. Memory is what allows us to learn how to use tools, remember previous experiences, and retain knowledge for use from one session to the next (Johnson, 2021). This is not all of what 
               memory is or does for people but for the purposes of this blog post this is good enough of an understanding. Mental models on the other hand are exactly what they sound like, models built in the mind, but more detail is needed than just that of course. Mental models 
               are summarizations of the world around us built by the mind to make things easier to understand and deal with by the human mind. If you want a good quote to use that summarizes what I was trying to say better, “A mental model is a model that is constructed and simulated within a 
               conscious mind” (Merrit, 2016), this holds the essence of what I was trying to get at. With these two concepts established we can move on to the next section of this post, how these two influence user interaction. </p>
            <h3>Memory, Models, and User Interaction</h3>
            <p>Now with the two major definitions set down, we need to know what is meant when user interaction is mentioned. User interaction is just when a user/person interacts with a feature of a system, design, or structure, in this case we will be focusing on digital interactions 
               due to the overall focus of these blog posts, but the ideas introduced here can also be used in the world outside of circuits and wire. Knowing these things, we can look at how memory affects how people interact with systems. One of the big parts that memory contributes to user 
               interaction is the ability to remember what features do and where they are located. This is deeply important because it allows for people to learn how systems work and become more efficient with their use, however it can be a double bladed sword on occasion as the same ability 
               that allows for efficiency to grow also makes a sudden change, like a software update that reorganizes things, will throw people off for a while and cause speed to drop. That is why you generally do not see major changes to user interfaces happen often outside of a generational 
               change, an example of that would be the shift from Windows 10 to Windows 11, which can justify a major change in layout and functionality of a user interface. </p>
            <p>Mental models have larger scale than memory when it comes to user interaction, it sets the expectations going into new experiences by pulling on the memory of previous experiences to get an idea of what to expect from an upcoming task or endeavor. An example of this is when a
                new system is described to you as ‘like’ another thing, the brain starts to build an idea of what to expect off of the user interface or functionality of the referenced thing. You could describe an application like Microsoft Word as ‘like’ a typewriter, this misses several key 
                features of what Word is but it distils the essence of it into something that can be understood by someone who knows what a typewriter is granting them some ground to stand on when it comes to getting started at least. An example of a bad mental model harming the initial adoption 
                of a new user interface is… the transition from Windows 10 to 11 really, there were many minor format changes and functionality changes when the new version was released that made the initial adoption rather difficult for the early switchers and made enthusiasm for the new product 
                crater out.</p>
            <h3>Reasons for Consistency</h3>
            <p>I have brushed against this topic in my previous paragraphs, but I have not directly said anything about it, being consistent with other user interfaces is a good idea for a new user interface. There are several reasons why, one is that it allows users mental models to work for 
               them instead of against making adapting new systems easier. Being externally consistent makes an environment where “users do not have to learn new representations for each task… allow users to complete new tasks without having to learn a whole new toolset” (Wong, 2019). There is a
                law that helps with the structure of making things consistent, Tesler’s Law. This law argues that spending development time to reduce complexity for users will save enough time on a grand scale to make the added app complexity worth the overall cost in development time (Yablonski,
                 2024). All of this is an argument to make things simple for the average user because it will make them more efficient where it matters and happier with the end product if it comes in an easy to understand package.</p>
            <footer class="article-footer">
               <h3>Sources:</h3>
                  <ol>Johnson, J. (2021). <em>Designing with the mind in mind : simple guide to understanding user interface design guidelines</em> (Third edition.). Morgan Kaufmann Publishers.</ol>
                  <ol>Merritt, J. (2016). <em>What Are Mental Models?</em> The Systems Thinker. <a href="https://thesystemsthinker.com/what-are-mental-models/">https://thesystemsthinker.com/what-are-mental-models/</a></ol>
                  <ol>Wong, E. (2019). <em>Principle of Consistency and Standards in User Interface Design</em>. The Interaction Design Foundation; UX courses. <a href="https://www.interaction-design.org/literature/article/principle-of-consistency-and-standards-in-user-interface-design">https://www.interaction-design.org/literature/article/principle-of-consistency-and-standards-in-user-interface-design</a></ol>
                  <ol>Yablonski, J. (2024). <em>Laws of UX</em> (2nd ed.). O'Reilly Media, Inc.</ol>
            </footer>
          </article>
         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
      <footer class="page-footer">
       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>