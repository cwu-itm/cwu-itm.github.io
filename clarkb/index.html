<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Brandon Clark | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>
         <!-- Module 1.1 Blog Post Starts Here-->
         <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>
            <h3>Systems Thinking and Digital Systems</h3>
            <p>Technology, and its evolution, have caused them to no longer be perceived as neat pieces that easily fit together. They have become dynamic, constantly changing systems that all work in tandem from interactions of external influence like people, code, businesses, platforms, and so much more. To adapt to this ever-changing landscape of digital environments, there must be a mindset and looks further than just the individual pieces of the puzzle, this is where Systems Thinking comes into play, it allows us to see deeper into the connections, patterns, and structure within these environments. This perspective aligns with engineering principles and prioritizes system structure, boundaries, and interactions, rather than just isolating elements (Holt, 2022).</p>
            <p>This post will go into detail about what Systems Thinking means from my own perspective. I will also compare it to linear thinking, and how it differentiates from systems thinking and how systems thinking is better. I will also touch of the subject of using model-based approaches to apply this type of thinking to digital systems.</p>
            <h3>What is Systems Thinking?</h3>
            <p>To myself, Systems Thinking involves looking at instances through a lens of connectivity. Thinking about how parts worked together to create a phenomenon, rather than focusing on one individual portion. Rather than asking “What single piece caused this issue?” systems thinking turns the perspective into </p>
            <p>This mindset comes from the insight that most instances – especially when it comes to complex systems and software ecosystems – are not caused by one individual issue, rather a multitude of different things collaborating to create the result. To give an example, if a glitch or bug shows up in an application, it might not be as simple as a singular line of code. It could very well rather be a plethora of issues, ranging from architecture decisions, constraints in multiple areas, and more.</p>
            <p>Those who use Systems Thinking map out these patterns, keeping a focus on the structure and behavior, rather than just relying on snapshots. This mindset is surrounded by understanding systems and their behavior involves identifying relationships, both linear and non-linear, delays, properties, elements that linear thinking usually overlooks.</p>
            <h3>How Does System Thinking differ from Linear Thinking?</h3>
            <p>When it comes to linear thinking, problems are usually broken down into individual pieces, isolate issues, and use simple cause-to-effect reasoning to fix problems. This works with issues that involve mechanical portions, controlled environments and more. Mostly where events are easily predictable and the rules governing them are simple.</p>
            <p>Digital systems, however, are never that simple. They constantly grow in complexity and adapt to the environment they are exposed to. The smallest of changes can end up causing a ripple effect through the rest of the system, especially towards the connections that are directly affected by that change, which leads to side effects that are difficult to foresee (Meadows, 2008). FI something changes about a website, it can affect engagement metrics, which can create a domino effect that could affect countless other things.</p>
            <p>In Laws of UX, Yablonski enforces that digital systems need to consider psychological principles – how people will see, interact, and interpret with their interfaces – and that these behaviors have just as much influence on the behavior of systems as technical constraints and more (Yablonski, 2025). This is a representation of a systems perspective, design decisions have the power to create ripple effects through expectations, long-term habits from users, and expectations.</p>
            <p>To contrast, linear thinking could be revamping a websites design and not taking any indication into how it could affect the user base for that website. Decisions, and the mindsets behind them, can cause unforeseen issues with a system, and its performance.</p>
            <h3>Characteristics of Systems Thinking</h3>

<!--INSTRUCTOR COMMENT: Rather than add in the numbers with the text, you can use an ordered list as coded below.-->

            <ol>
               <li>Feedback loops and their Behavior: Systems Thinking focuses on how outputs on a system will loop back as inputs, which influences that system behavior in the future. Reinforcing these loops and speed up changes, while keeping them balanced can stabilize behaviors. Linear thinking does not take these variables into account.</li>
               <li>Emergence: Complex systems will often show behavior categorized as “emergent”, meaning that they cannot be predicted by analyzing components by themselves. For an example, the collective user behavior on a website can project itself as patterns that were never specifically coded for.</li>
               <li>Mental Models: Systems thinking encourages using the mental models, these are internal representations that form how we interpret a system. Identifying these mental models helps reveal these assumptions and broadens systems boundaries, including people, environments, and policies.</li>
            </ol>

            <p>These characteristics steeply contrast reductionist, linear approaches that can assume that problems are easily solved by breaking them down into smaller, contextless pieces.</p>
            <h3>Model-Based Approaches</h3>
            <p>While systems thinking provides the framework, utilizing model-based designs gives tools to reason with complex systems. Models can start as simplified representations of the world, diagrams, simulations, maps and more. These overall are mea</p>
            <p>This appraoch is valuable for several reasons:</p>

<!--INSTRUCTOR COMMENT: Now, you can edit this one to create an ordered list.-->

            <ul>
               <li>1.	Interdependencies: Models like a causal loop diagram or other system maps can explicitly show relationships. Rather than expecting a developer to know how a microservice can interact with others, these models clearly show those links, along with tracking dependencies, and exposing hidden couplings throughout the system. This is extremely helpful when teams and codebases are massive.</li>
               <li>2.	Scenario Exploration: Models allow designers to test hypothetical scenarios before deploying any actual changes, that way any effects can be observed and compensated for. For an example, digital designers could see how changing an onboarding flow might change user retention and its support load.</li>
               <li>3.	Communication: Models can serve as shared artifacts across different subjects – UX, system engineering, management, developer operations – aligning expectations and production languages. Without these shared models, confusion can arise quickly in decision making.</li>
            </ul>
            
            <p>The academic piece on SYMBIOSIS emphasizes this point: allowing frameworks and models through systems thinking accessible – especially with AI and machine intelligent systems – dramatically improves formulation for problems and reduce barriers to a better understanding of complex structures (Sethi et al., 2025). This work showcases that models are not optional extras; they act as bridges to simplify super complex dynamics into representations that are much more interpretable.</p>
            <h3>Applications to Digital Design</h3>
            <p>Systems thinking has actual benefits in designing digital systems:</p>
            <ul>
               <li>1.	Leverage Points: Rather than optimizing performance metrics for efficiency, designers can look for leverage points, where small changes can have a massive turnaround or effect on the rest of the system.</li>
               <li>2.	Unintended Consequences: Changes often end up backfiring when secondary effects are brushed off. For example, streamlining a checkout process can help increase conversions but could also overload customer support if not coupled with better help services. Model-based analysis is helpful for capturing these effects.</li>
               <li>3.	Fostering Innovation: Systems thinking prioritizes long-term viability over short term fixing. In Law of UX, there is an emphasis on human psychology and a reminder to designers to think about users as more than just a number, but as a participant in a system whose expectations will shape the system’s evolution (Yablonski, 2025).</li>
            </ul>
            <h3>Conclusion</h3>
            <p>Complex digital systems act more like ecosystems than just machines. The dynamics of these systems come from intertwining technical, social, and behavioral elements. Linear thinking falls short in capturing this type of complexity.</p>
            <p>Systems thinking takes the focus from individual elements to internal relationships and patterns over time. It allows designers to map feedback, revisit assumptions, and find leverage points that could influence system behavior. When pairing with a model-based approach, systems thinking becomes much more flexible, models showcase assumptions, facilitate collaboration, and make interactions tangible.</p>
            <p>In the realm of digital design, systems thinking with modeling isn’t just helpful, it is necessary for creating resilient, adaptable, and human-oriented technology.</p>
            <footer class="article-footer">
                <h3>Sources:</h3>
                <ol>
                    <li>Sethi, S., Martin Jr., D., & Klu, E. (2025). SYMBIOSIS: Systems thinking and machine intelligence for better outcomes in society (preprint). arXiv. https://arxiv.org/abs/2503.05857</li>
                    <li>Yablonski, J. (2025). Laws of UX: Using psychology to design better products & services (2nd ed.) [eText edition, ISBN 9781098146924]. O’Reilly Media.  </li>
                    <li>Meadows, D. H. (2008). Thinking in systems: A primer. Chelsea Green Publishing.  </li>
                    <li>Holt, J. (2022). Systems engineering demystified (2nd ed.). Packt Publishing.</li>
                    </ol>
            </footer>
         </article>

         <!-- Module 1.2 Blog Post Starts here -->
         <article>
            <header class="article-header">
               <h2>Module 1.2 Blog Post</h2>
            </header>
            <h3>Systems Engineering as a Life Cycle:</h3>
            <p>Systems engineers are usually described as those who “build systems”, which is a very simplistic way to look at what they do. Systems engineers are what guide those systems through their entire existence, from the moment of its inception to the moment it is shut down or retired. This perspective usually separates systems engineers from the other branches of engineering. They focus on long-term solutions, system relationships, evolution, and more, rather than just focuses on the parts themselves.</p>
            <p>To manage all this information, systems engineers like to use life cycle models. This gives them a brief, but detailed, look of what that system’s life cycle will look like. A life cycle model provides a lot of crucial information, allowing it to organize elements like the design, implementation, deployment, operation, and other considerable parts of the development process. These models help reduce the confusion, the uncertainty, and can help reduce the likelihood of unaccounted issues showing up in the future. In Systems Engineering Demystified, there are three different models of life cycles: linear, iterative, and incremental (Walden et al., 2023). Each of these have their own attributes that allows them to work better for different aspects and scenarios.</p>
            <p>This post will cover what those differences are, along with how they work, the thought process behind them, and what scenarios they would be most effective in. It will also go into how these models can shape the mindset and thought process behind systems engineers, and how they approach problems in the real world.</p>
            <h3>The Purpose of Life Cycles:</h3>
            <p>It’s important to talk a little more about why these models are important to use in the first place. Systems engineering often involves running into problems that are massive, complex, and take a considerable amount of time. These problems could range from hardware, software, organizations, structure, and so many more. Without this level of structure, things can end up falling apart and cause major issues during the development of maintenance of systems.</p>
            <p>These cycles provide a means of structure and keeping everything concise. They make it easier to answer questions later involving when things should be done, how or when they should be tested, responsibility, feedback and more. According to Walden, life cycles models are not meant to be instructions but rather tools to support informed decision-making throughout the system’s life (Walden et al., 2023).</p>
            <p>Each of these models have their own priorities. Some of them focus on predictability and keeping control, while others can focus on learning, adapting to environments, and more. Knowing these differences is key to utilizing them to the best of their ability.</p>
            <h3>The Linear Life Cycle:</h3>
            <p>The linear model is more than likely the first one that is encountered in systems engineering, this is often referred to as the “waterfall” model, it keeps organization to a concise list of phases. These can often range from design, testing, deployment and everything in-between. All these phases are completed in sequence, one does not start until the one before it is complete. </p>
            <p>The biggest strength of the linear model is its clarity. Each phase has a clearly defined start to end, which means that responsibilities are easily assigned to each phase, steps are easily logged and tracked, and it is easier to track progress. This model works well with systems that have stable requirements, understood technology, and constraints around regulations and contracts. Safety-regulated systems involved in aerospace or defense agencies usually involve a linear life-cycle model due to the emphasis on documentation and verification (INCOSE, 2015).</p>
            <p>Unfortunately, the linear model has its limitations. It introduces assumptions per-development that all the goals and requirements can be fully grasped by the end of the project. In most modern systems, this is not the case. There are several variables to consider, user needs change, technology’s constant evolution, and more. Since portions like feedback occur towards the end of that process, errors that are discovered through development can become problematic.</p>
            <p>For systems engineers, this linear model helps upfront thinking but distances from adapting and ability. Using this model, systems engineers need to be very diligent during the early phases of this process, since early decisions can have a major impact on later instances.</p>
            <h3>The Iterative Life Cycle:</h3>
            <p>The iterative life cycle model was created as a response to the limitations of the linear approach. Instead of just progressing through a development cycle once, this cycle emphasizes going through it several times, through evaluation, refinement, and more. Multiple aspects of said development are revisited as a result. </p>
            <p>In an iterative life cycle model, early iterations of a system could be incomplete or missing parts. Constantly going through the development cycle allows feedback to be placed through that process. According to Walden, iteration allows systems engineers to manage uncertainty effectively by using development as a learning process rather than a one-and-done plan (Walden et al., 2023).</p>
            <p>One of the main advantages of the iterative cycle is risk reduction. By testing earlier and more often, problems, both conceptually and technically, can be identified and helped before they become too engrained in the system. Iterative life cycles can also help significantly with feedback, allowing people to access an earlier build while inviting comments or critiques that could be implemented later.</p>
            <p>Where there are advantages, there are also challenges.  Constant cycling can lead to scope creep, scheduling issues, and fatigue amongst stakeholders. Engineers need to balance flexibility and discipline to keep these issues at bay. This involves thinking skills and evaluating with additions add value rather than just delaying progress.</p>
            <h3>The Incremental Life Cycle:</h3>
            <p>The incremental life cycle model shares some aspects with iterative models but focuses mostly on delivering functional pieces of a system in increments. Rather than starting the development cycle from the beginning, the incremental cycle is built around focusing on certain aspects of a system and deploying them once they reach a certain level of functionality. This approach lets stakeholders realize the value in decisions while also validating the requirements for the project in real-world usage (Boehm, 1988).</p>
            <p>Incremental development is best suited for systems that can show considerably more value over time and released gradually. Software-crucial systems are a good example, showing that basic functionality can be implemented first, and then extra features can be added in later. This model supports early feedback while also validating the requirements set for the project.</p>
            <p>Walden notes that incremental models encourage a strong relation between development and stakeholder value. Each increment in development serves as a result that can be tested in real-world aspects. This gives it an opportunity to justify its further investment and development (Walden et al., 2023).</p>
            <p>The challenges with the incremental life cycle involves long-term integration and overall coherence. As more and more increments are added, the system must be robust enough to support these additions and not end up becoming too complex or difficult. Systems engineers play a crucial part in making sure that small increments do not compromise long-term stability.</p>
            <h3>Comparing These Models:</h3>
            <p>There is no life cycle that is considered the “best.” Each one has their own strengths and are used for specific instances, with trade-offs involving flexibility, learning, and risk. The linear model provides a straightforward “start to finish” process. The iterative model uses something similar but allows engineers to revisit aspects of the development cycle while implement feedback and fixing other issues. Finally, the incremental cycle focuses more on keeping the value of a project through slow but complete implementation, ideal for systems that tend to change over time.</p>
            <p>Many real-world systems use a mesh or hybrid of different elements of these cycles to strike a balance. A system may follow a majority linear structure at an architecture level, while using iterative and incremental cycles during testing, development, feedback, and more. Systems engineers need to understand not only the models themselves but also how to tailor and integrate them to fit their needs and situations (INCOSE, 2015).</p>
            <h3>The Role of the Systems Engineer:</h3>
            <p>No matter which life cycle is chosen, the role of the systems engineer stays relatively the same: to keep a holistic view of the system while also guiding it to a successful outcome. Life cycles can change how this role is carried out, but the thought process of the system does not change. </p>
            <p>For linear models, systems engineers act as someone to uphold requirements and guidelines, keep consistency and traceability. In iterative models, they act as a facilitator of learning, helping teams interpret feedback into change and adjusting to do so. For incremental, a system engineer acts as an integrator and an architect, making sure every addition can fit into the overall vision.</p>
            <p>Making sure that life cycles are understood is what ends up shaping how systems engineers think about time, responsibility, and change. Rather than looking at development as a single instance, it is seen as an ongoing process that extends all the way to the end of the systems life cycle.</p>
            <h3>Conclusion: Life Cycles as Thinking Tools:</h3>
            <p>Life cycles are much more than just diagrams to visualize a process; they are examples of how a systems engineer thinks about the development process and its complexity, change, and uncertainty. The linear, iterative, and incremental models offer three distinct pathways to tackle that process. They are three different perspectives on how a system can be developed and sustained. By knowing their assumptions, limitations, and strengths, is it easier to determine which models support the challenges they will be facing.</p>
            <p>Effectively engineering systems is not just about following a rigid model but using them as guides. As shown in Systems Engineering Demystified, successful systems engineers remain flexible, reflective, and focused primarily on the system’s long-term success, rather than settling for short-term convenience (Walden et al., 2023). These models provide the structure to support that mindset, assisting engineers work through complexity with full clarity and intention.</p>
            <footer class="article-footer">
                <h3>Sources:</h3>
                <ol>
                    <li>INCOSE. (2015). INCOSE systems engineering handbook: A guide for system life cycle processes and activities (4th ed.). Wiley.</li>
                    <li>Walden, D. D., Roedler, G. J., Forsberg, K. J., Hamelin, R. D., & Shortell, T. M. (2023). Systems Engineering Demystified. Springer. ISBN: 9781098146924</li>
                    <li>Boehm, B. W. (1988). A spiral model of software development and enhancement. Computer, 21(5), 61–72. https://doi.org/10.1109/2.59</li>
                    </ol>
            </footer>
         </article>
         <!-- Module 2.1 Blog Post Starts here -->

         <!-- Module 2.2 Blog Post Starts here -->

         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
      <footer class="page-footer">
       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>