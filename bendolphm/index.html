<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Student Name | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>
         <!-- Module 1.1 Blog Post Starts Here-->
         <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>
            <h3>Health Cronut la Croix</h3>
            <p>I'm baby photo booth fingerstache af enamel pin quinoa. Portland unicorn keytar paleo letterpress banjo kinfolk. Pitchfork four loko meditation, locavore marfa af listicle sriracha helvetica cred vexillologist PBR&B. Pop-up hexagon thundercats master cleanse before they sold out, fashion axe copper mug yes plz literally cred mukbang chia gluten-free. Bodega boys skateboard ugh green juice. Hella marxism succulents mumblecore forage kale chips bespoke fixie shoreditch chartreuse tofu before they sold out.</p>
            <h3>Offal Tofu Cred Green Juice</h3>
            <p>Microdosing portland banh mi bitters, pitchfork ethical selvage plaid keytar jianbing kickstarter cronut. Truffaut schlitz ennui, migas aesthetic letterpress la croix. Health goth 8-bit microdosing, cronut offal gluten-free tbh cornhole swag YOLO vape man bun godard. Pitchfork semiotics hella salvia kickstarter jean shorts. Air plant thundercats kombucha gentrify portland.</p>
            <h3>Blue Roof Pour-Over Man Bun</h3>
            <p>Yuccie mukbang pickled activated charcoal. PBR&B selfies DSA mustache authentic. Gochujang kombucha big mood retro, you probably haven't heard of them +1 lomo. Tbh pour-over yr viral gorpcore poutine four dollar toast. Bicycle rights man bun try-hard, mlkshk roof party occupy succulents taxidermy kogi enamel pin brunch paleo poutine yr. Blue bottle street art waistcoat typewriter yr hot chicken polaroid helvetica pitchfork.</p>
            <ul>
               <li>Neutra umami slow-carb vegan dreamcatcher.</li>
               <li>Tacos cornhole humblebrag ethical.</li>
               <li>DSA santo big mood organic charcoal bitters.</li>
               <li>Hot chicken pitchfork poutine.</li>
            </ul>
            <h3>Mlkshk Stumptown Hot Chicken</h3>
            <p>Next level gluten-free whatever, tacos activated charcoal bitters woke. Mlkshk photo booth bicycle rights paleo, butcher DIY ugh mukbang bespoke occupy affogato jawn adaptogen artisan tofu. Tbh gentrify you probably haven't heard of them neutra umami slow-carb vegan dreamcatcher waistcoat. Tacos cornhole humblebrag ethical austin neutra plaid. Sustainable gatekeep ugh locavore deep v, palo santo stumptown skateboard big mood organic lumbersexual mustache cornhole hot chicken. Gluten-free artisan cliche mumblecore af, edison bulb meditation messenger bag.</p>
            <footer class="article-footer">
                <h3>Sources:</h3>
                <ol>
                    <li>Sherugar, S., & Budiu, R. (2016, August 21). <em>Direct manipulation: Definition</em>. Nielsen Norman Group. Retrieved March 19, 2025 from <a href="https://www.nngroup.com/articles/direct-manipulation/">https://www.nngroup.com/articles/direct-manipulation/</a></li>
                    </ol>
            </footer>
         </article>

         <!-- Module 1.2 Blog Post Starts here -->
<P>Welcome back to another blog post with your host... Marius Bendolph! It was an interesting week; A "super flu" followed by a stomach bug going around, a 3 day weekend, and feeling like its still Christmas time? It really is an interesting week, but not as interesting as our section .2 in module 1. Let's get into it, i'll fill you in!</P>
          <P><strong>20JAN2026</strong></P>
          <h1>1.2 Blog Post: Thinking in Life Cycles</h1>
          <p>
            In systems engineering, a “life cycle” is not just a timeline, it’s a way of organizing decisions about requirements, design, 
            verification/validation, deployment, and sustainment so the system remains useful over time. The model you choose shapes how your
            team handles uncertainty, how quickly you can learn from real-world feedback, and how painful (or manageable) change becomes.
            In <em>Systems Engineering Demystified</em>, Holt emphasizes that life cycles are essential for understanding how systems evolve,
            but they are often oversimplified in practice because real systems are complex and interconnected (Holt, 2023).
         </p>

         <p>
            This post compares three common life cycle models: <strong>linear</strong>, <strong>iterative</strong>, and <strong>incremental</strong> and
            explains when each makes sense. I also connect Holt’s explanations to two widely recognized external references: the
            ISO/IEC/IEEE 15288 standard for system life cycle processes (ISO/IEC/IEEE, 2015) and the NASA Systems Engineering Handbook
            (NASA, 2016). The goal is not to “pick a winner,” but to understand what each model optimizes for and what tradeoffs you accept
            when you commit to it.
         </p>

         <h2>Why life cycle thinking matters more than it sounds</h2>

         <p>
            The easiest mistake to make is to treat a life cycle model like a checklist. In reality, a life cycle model is a strategy for
            managing risk. It sets expectations about when you lock decisions, when you can revisit assumptions, and how you prove that the
            system is ready to move forward. Holt points out that in real organizations, systems often involve multiple life cycles happening
            at the same time, with interaction points that may shift or appear unexpectedly (Holt, 2023). That means a model that looks
            “clean” on paper can fail in practice if it doesn’t match the system’s environment and stakeholder behavior.
         </p>
         
         <p>
            Another reason life cycle thinking matters: <em>systems are not isolated</em>. A system is made of interconnected elements within a
            boundary, and it interacts with its environment through interfaces (Holt, 2023). Those interfaces may exchange information,
            energy, materials, money, or combinations of these, and complex systems can have many interfaces and internal interactions.
            When you choose a life cycle model, you are also choosing how you will discover, define, and control those interfaces over time
            (Holt, 2023).
         </p>

         <h2>The basic life cycle “stages”</h2>
         
         <p>
            Holt describes life cycles using stages (such as concept, development, production, and utilization) that represent the kinds of
            activities a system typically goes through from idea to real-world use (Holt, 2023). The three models in this post arrange those
            stages differently and repeat them in different ways.
         </p>
         
         <ul>
            <li><strong>Concept</strong>: define the problem, stakeholders, and what “success” means.</li>
            <li><strong>Development</strong>: shape the solution, design the architecture, and reduce uncertainty.</li>
            <li><strong>Production</strong>: build/implement the system elements and integrate them.</li>
            <li><strong>Utilization</strong>: operate the system in the real environment and learn from performance.</li>
            <li><strong>Sustainment &amp; retirement</strong>: maintain, update, and eventually dispose/replace the system when needed.</li>
         </ul>
         
         <p>
            ISO/IEC/IEEE 15288 frames similar work using defined process groups and technical processes that apply across a system’s life
            (ISO/IEC/IEEE, 2015). NASA also treats systems engineering as an activity that spans the full life cycle rather than a single
            “phase” you finish and forget (NASA, 2016). This matters because life cycle models are ultimately about <strong>when</strong> and
            <strong>how</strong> you apply those processes to guide decisions.
         </p>
         
         <h2>Model #1: Linear life cycle (clear phases, controlled transitions)</h2>
         
         <p>
            A linear model moves through the stages in a mostly one-way flow. The basic idea is simple; do concept work, then development,
            then production, then utilization. Linear approaches are attractive when the system is short, well-defined, and unlikely to face
            major requirement changes. The “best case” is a stable environment where stakeholders agree early, requirements can be
            documented clearly, and the system’s interfaces and constraints can be managed without constant redesign (Holt, 2023).
         </p>
         
         <h3>Strengths of linear approaches</h3>
         <ul>
            <li><strong>Clarity</strong>: everyone knows what stage the project is in and what deliverables are expected.</li>
            <li><strong>Control</strong>: reviews and gates can enforce discipline before the team moves forward.</li>
            <li><strong>Auditability</strong>: documentation and traceability are easier to maintain in regulated contexts.</li>
         </ul>
         
         <h3>Weaknesses of linear approaches</h3>
         <ul>
            <li><strong>Change is expensive</strong>: late discoveries often trigger rework across multiple stages.</li>
            <li><strong>Feedback arrives late</strong>: you may not find real-world usability or integration issues until deployment.</li>
            <li><strong>False certainty</strong>: a “complete” requirements set early on can be an illusion when stakeholders learn over time.</li>
         </ul>
         
         <p>
            In other words, the linear model tends to work best when uncertainty is already low, or when constraints demand strict control.
            If uncertainty is high, the linear model can create brittle plans that look confident until reality forces change.
         </p>
         
         <h2>Model #2: Iterative life cycle (repeat the stages to learn faster)</h2>
         
         <p>
            Holt describes iterative life cycles as an approach built on a practical assumption; if a linear model works for small,
            well-defined projects, you can break a large complex system into a series of shorter, simpler “mini life cycles,” called
            iterations (Holt, 2023). Each iteration passes through the stages and produces a workable version of the final system that can
            be deployed in the target environment (Holt, 2023).
         </p>
         <p>
            The iteration-by-iteration idea changes how teams think. Instead of betting everything on a single final delivery, the team
            treats each iteration as a learning opportunity. Holt notes a key benefit: each release is typically more complete and improved
            compared to the previous one, and if a release is a disaster, it can be easier to revert to a prior version and restore
            functionality (Holt, 2023).
         </p>
         
         <h3>Advantages of iterative approaches</h3>
         <ul>
            <li><strong>Earlier feedback</strong>: you learn from real use sooner, not at the end.</li>
            <li><strong>Risk reduction</strong>: you can detect integration or performance issues earlier.</li>
            <li><strong>Continuous improvement</strong>: each cycle refines requirements and design based on evidence.</li>
         </ul>
         
         <h3>Real-world cautions Holt emphasizes</h3>
         <ul>
            <li>
               <strong>Schedule-driven releases</strong>: Holt points out that in software contexts, iterative cycles may push teams to ship on time
               rather than wait for something that truly works (Holt, 2023).
            </li>
            <li>
               <strong>Stakeholder volatility</strong>: iterative approaches can invite frequent changes in basic needs, so a robust needs process is
               critical and often missing (Holt, 2023).
            </li>
         </ul>
         
         <p>
            A common misconception is that iterative delivery conflicts with Model-Based Systems Engineering. Holt explicitly rejects this:
            MBSE can be applied wherever you need to control complexity, define understanding, and communicate with stakeholders (Holt, 2023).
            That’s a major point: iteration does not remove the need for disciplined engineering; it increases the need for strong models,
            traceability, and well-defined interfaces because you are making changes more frequently.
         </p>

         <h2>Model #3: Incremental life cycle</h2>
         
         <p>
            Holt explains that the incremental model is similar to the iterative model in that the system is delivered through multiple
            passes and multiple releases both are often grouped as “evolutionary” models (Holt, 2023). The difference is the structure:
            in an incremental approach, the concept stage covers <em>all</em> needs up front, but later development and production focus on
            subsets of needs to produce a partial solution that can be deployed (Holt, 2023).
         </p>
         
         <p>
            Put simply, iterative development often emphasizes refining the same overall product repeatedly, while incremental delivery
            emphasizes expanding capability by delivering chunks of the overall system. Holt highlights an important advantage: the system
            can be seen working earlier, even if deployed in reduced form compared to the final system (Holt, 2023). That can be valuable
            when stakeholders need operational capability sooner, or when you want early “proof of value” while you continue building.
         </p>
         
         <h3>Strengths of incremental approaches</h3>
         <ul>
            <li><strong>Early operational value</strong>: stakeholders get usable capability sooner.</li>
            <li><strong>Funding and support</strong>: visible progress can help sustain organizational buy-in.</li>
            <li><strong>Focused scope per release</strong>: teams can isolate complexity into manageable delivery blocks.</li>
         </ul>
         
         <h3>Weaknesses of incremental approaches</h3>
         <ul>
            <li><strong>Integration burden</strong>: each new increment must integrate cleanly with what already exists.</li>
            <li><strong>Architecture pressure</strong>: early decisions must support future increments, or growth becomes painful.</li>
            <li><strong>Interface creep</strong>: partial deployments can multiply interfaces and operational constraints.</li>
         </ul>
         
         <h2>Life cycle models in real systems: interfaces, boundaries, and “multiple life cycles”</h2>
         
         <p>
            The reason life cycles become complicated is that systems interact. Holt defines a system as a set of interconnected elements
            inside a boundary, and emphasizes that interfaces are the connections between the system and its environment (Holt, 2023).
            In practice, those interfaces are where many projects struggle, especially when multiple organizations, suppliers, or legacy
            systems are involved.
         </p>
         
         <p>
            Holt also warns that the “single life cycle diagram” is often not the full story. Large organizations may run multiple life cycles
            simultaneously for different subsystems, and those life cycles may intersect at critical points (Holt, 2023). That explains why
            teams can feel like they are “doing iterative development” while their acquisition or governance structure forces linear gates.
            Life cycle alignment is not only a technical issue, it’s organizational.
         </p>
         
         <h2>Processes across the life cycle: why verification and validation can’t be an afterthought</h2>
         
         <p>
            Chapter 5 shifts from life cycle models to the processes that make systems engineering work. Holt says processes lie at the heart
            of systems engineering because systems engineering is an approach to realizing successful systems (Holt, 2023). In other words,
            life cycle models are the “shape,” but processes are the “engine” that moves the work forward.
         </p>
         
         <p>
            Holt also lists desirable process properties. One clearly stated property is that processes must be <strong>repeatable</strong>,
            meaning they can be executed consistently by stakeholders (Holt, 2023). Repeatability matters because when teams are large,
            distributed, or working with suppliers, “how we do things” must be stable enough to produce reliable outcomes.
         </p>
         
         <p>
            Holt uses ISO 15288 as a concrete example and describes process groups including Agreement, Organizational Project-Enabling,
            Technical Management, and Technical Processes (Holt, 2023). Within the technical processes, ISO 15288 includes activities such as
            stakeholder needs and requirements, system requirements, architecture definition, design definition, implementation, integration,
            verification, validation, operation, maintenance, and disposal (Holt, 2023; ISO/IEC/IEEE, 2015).
         </p>
         
         <h3>Verification vs. validation: A difference that affects every life cycle model </h3>
         
         <p>
            ISO 15288 (as summarized by Holt) distinguishes verification and validation in a way that directly connects to life cycle models:
         </p>
         
         <dl>
            <dt><strong>Verification</strong></dt>
            <dd>
               Providing objective evidence that a system (or system element) fulfills its specified needs (Holt, 2023).
            </dd>
            <dt><strong>Validation</strong></dt>
            <dd>
               Providing objective evidence that the system, when in use, fulfills its intended purpose in its intended operational environment
               (Holt, 2023).
            </dd>
         </dl>
         
         <p>
            That distinction is one reason iterative and incremental models can be powerful: they can deliver earlier chances to validate in
            the real environment. But it’s also why those models can fail if teams focus only on shipping increments without maintaining
            disciplined verification and requirements traceability.
         </p>
         
         <h2>A practical way to choose between linear, iterative, and incremental</h2>
         
         <p>
            If you are deciding which model makes sense, think in terms of uncertainty and constraints. Holt’s discussion implies that model
            choice should reflect stakeholder behavior, system complexity, and how fast the team needs feedback (Holt, 2023). ISO 15288 and
            NASA both reinforce the idea that systems engineering processes span the life cycle, so the question becomes: <em>how will you
               structure learning and control?</em> (ISO/IEC/IEEE, 2015; NASA, 2016).
            </p>
            
            <ol>
               <li>
                  <strong>Assess volatility:</strong> If stakeholder needs are likely to change frequently, iterative/incremental approaches can
                  handle learning better,<em>if</em>, you have a robust needs process (Holt, 2023).
               </li>
               <li>
                  <strong>Assess integration risk:</strong> If interfaces and integration are high-risk, plan for earlier integration and earlier
                  evidence. Incremental delivery can help, but it also creates repeated integration events.
               </li>
               <li>
                  <strong>Assess compliance and governance:</strong> If strict gates, audits, or certification dominate, a linear structure may be
                  required, but you can still incorporate iterative learning inside phases (NASA, 2016).
               </li>
               <li>
                  <strong>Plan verification and validation intentionally:</strong> Don’t push validation to the end. Use the model to create
                  opportunities to validate in realistic conditions (Holt, 2023; ISO/IEC/IEEE, 2015).
               </li>
            </ol>
            
            <h2>Final Thoughts</h2>
            
            <p>
               The biggest takeaway from Chapters 3-5 is that life cycle models are not just academic diagrams. They affect how teams think about
               boundaries, interfaces, and change. Holt’s argument that life cycles are often oversimplified is not pessimistic, it is realistic.
               Real systems are built inside organizations, connected to environments, and shaped by stakeholders who learn over time (Holt, 2023).
            </p>
            
            <p>
               Linear models provide clarity and control when uncertainty is low or governance is strict. Iterative models create faster learning
               loops and reduce the risk of betting everything on a single delivery, but they demand strong needs management and disciplined
               engineering. Incremental models deliver capability earlier and build momentum, but they put pressure on architecture and integration.
               No matter the model, the core processes/needs, requirements, architecture, design, integration, verification, validation,
               operations, maintenance, and disposal still matter, and standards like ISO 15288 and guidance like NASA’s handbook exist because
               consistent process execution is what turns complexity into outcomes (Holt, 2023; ISO/IEC/IEEE, 2015; NASA, 2016).
            </p>
         <!-- Module 2.1 Blog Post Starts here -->

         <!-- Module 2.2 Blog Post Starts here -->

         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
      <footer class="page-footer">
       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>