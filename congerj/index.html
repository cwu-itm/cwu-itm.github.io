<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Jesse Conger | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>

<!--INSTRUCTOR COMMENT: I went ahead and cleaned up the, reorganized it a bit and remvoved the placeholder content. Please see my additional comments below.-->

          <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>

<!--INSTRUCTOR COMMENT: For each of the paragraphs of text, you'll need to wrap them in paragraph tags. I did the first one for you as en example.-->

            <p>The Systems Development Life Cycle (SDLC) is basically a structured process that helps guide how digital systems are planned, built, and maintained over time. This paper explains the SDLC in straightforward terms and takes a close look at three common development models, linear, iterative, and incremental. It discusses what makes each model unique, along with their strengths and weaknesses. It also highlights why thinking about a system’s full life cycle matters when aiming for long lasting, secure, and adaptable technology. Understanding these approaches is important because they help developers reduce risk, handle changes more effectively, and build systems that remain dependable long after they’re deployed. Overall, the goal is to show why SDLC models continue to play an essential role in designing and managing modern digital systems.</p>

            Digital systems today range from simple business tools to large cyber physical platforms, and they are becoming more complex, more connected, and more essential to how organizations operate. As systems grow in scale and importance, organizations turn to structured development methods to keep projects organized and manageable. One of the most commonly used approaches is the Systems Development Life Cycle, or SDLC. It outlines a clear set of phases that guide a system from the earliest planning discussions through long term maintenance. Using the SDLC helps teams work in an organized way, manage risks more effectively, and keep projects within expected timelines and budgets. Research in software engineering often explains that SDLC frameworks support better communication among stakeholders, strengthen quality control, and make systems easier to maintain over time (Visure Solutions, n.d.; FutureCode, 2025). This paper explains what the SDLC means in practical terms, reviews three widely used models known as the linear, iterative, and incremental models, and discusses why viewing systems through a life cycle perspective leads to stronger and more resilient digital system design.

            The Systems Development Life Cycle is a clear and organized way to guide the planning, creation, and long term support of a software system. It divides development into recognizable phases that include planning, analysis, design, development, testing, deployment, and maintenance. This structure gives teams a straightforward blueprint to follow and ensures that each phase is completed with purpose before moving on to the next. Visure Solutions (n.d.) explains that the SDLC focuses on delivering reliable and well built systems by following a methodical process that moves step by step from initial planning through continued maintenance. This approach makes it easier to identify risks early, maintain oversight throughout the project, and confirm that the final system meets the needs of its intended users. [visuresolutions.com] FutureCode (2025) also notes that the SDLC improves development speed, encourages thorough testing, and supports predictable and efficient results, which helps keep projects aligned with larger organizational goals. [future-code.dev]

            The linear or Waterfall model is considered one of the earliest and most formal development approaches. It follows a sequence in which the team completes requirements, then moves to design, then development, then testing, followed by deployment and ongoing maintenance. Once the team completes a phase, the process continues forward without returning to earlier stages. GeeksforGeeks describes this approach as structured and easy to understand because it relies on the assumption that requirements are known and well established at the start of the project (GeeksforGeeks, 2026). [geeksforgeeks.org] Baeldung (2024) also emphasizes the strict order of phases in this model and explains that progress depends on finishing each stage fully before the next one begins. [baeldung.com] This model offers clarity because of its straightforward sequence, and the need for documentation in every stage supports stronger communication and helps track decisions clearly. It also promotes predictable planning because project teams can estimate timelines, budgets, and resources more easily when each phase is fixed and defined. However, it does not adapt well to change, because revisiting earlier work can be difficult and expensive, especially when new information or updated requirements emerge later in the project. Baeldung (2024) points out that this rigidity makes the model less suitable for projects in fast changing environments. [baeldung.com] Another challenge is that testing takes place only after development is complete, which may lead to the discovery of serious issues at a point when fixing them is more costly. GeeksforGeeks (2026) also notes that the model depends on the assumption that requirements will remain stable, which is rarely the case in many modern projects. [geeksforgeeks.org] Because of these limitations, the linear model works best in situations where requirements are well understood in advance and very unlikely to change.

            The iterative model takes a different approach by dividing development into repeated cycles of planning, design, development, and testing. Each cycle produces a working version of the system that can be reviewed and improved before moving forward. Teaching Agile explains that each iteration produces a functional prototype that allows stakeholders to see progress early and provide feedback that helps shape the next cycle (Talreja, 2025). [teachingagile.com] These cycles usually last a few weeks and give teams the opportunity to try ideas, evaluate results, and adjust the system based on practical insights before committing to a final design. This model supports flexibility because updates and new ideas can be incorporated throughout the project. It also encourages gradual improvement since each cycle builds on what came before it. Regular feedback from stakeholders helps ensure that the system stays aligned with user expectations and business needs, and the continuous testing built into every cycle helps identify problems long before the system is completed. Although this model offers many advantages, it also introduces challenges. It requires careful planning and coordination because each cycle must be structured in a way that prevents uncontrolled shifts in the project. It may also require more management effort because planning, testing, and feedback occur repeatedly rather than only once. Smaller teams may struggle with the workload involved in managing multiple cycles, especially if they do not have well established processes. Even with these challenges, the iterative model is highly effective when requirements are unclear at the beginning or expected to change over time, which is why it is commonly used in modern development environments.
         
            The incremental model is often discussed alongside the iterative model, but it focuses on dividing the system into separate modules that are developed and released individually. Each module serves as one piece of the system’s overall functionality. Literature on SDLC methods shows that each increment usually follows its own small scale development process, similar to a compact version of the Waterfall model (ReliaSoftware, 2024). [reliasoftware.com] This approach allows users to begin working with parts of the system before the entire project is finished, which can be valuable for gathering feedback or meeting early operational needs. It also offers better risk management because problems that appear within one module do not necessarily affect the rest of the system. Development can be more efficient as well because different teams can work on different modules at the same time. However, releasing the system in pieces can create challenges when it is time to integrate all the modules into a complete whole. If development teams follow different practices or fail to coordinate their work, the system may end up inconsistent in quality or design. This model also requires careful planning to ensure that the final system fits together smoothly, because without clear architectural guidance the completed product may feel fragmented. Even so, the incremental approach is highly useful for systems that benefit from modular design or need to deliver partial functionality early.

            Understanding and applying life cycle thinking is essential for building digital systems that remain dependable, secure, and adaptable over time. The SDLC encourages teams to think beyond the immediate needs of development and instead consider the entire life of the system from planning to retirement. A system that is sustainable is one that stays functional and secure throughout its full operational life. Life cycle approaches help teams evaluate their choices in terms of long term maintenance, system growth, and risk. Visure Solutions notes that SDLC frameworks help reduce risks by identifying problems early and applying structured quality controls throughout the project (Visure Solutions, n.d.). [visuresolutions.com] When developers take sustainability into account at each phase, the resulting system can adapt more easily to new technology or changes in user needs. Security also benefits from life cycle thinking because vulnerabilities often arise when security considerations are ignored during planning or design. SDLC models emphasize testing and evaluation at several points, which helps identify and fix weaknesses before the system is deployed. Iterative models in particular allow security issues to be examined and addressed during every cycle, leading to a stronger final product. Digital systems must also evolve over time, and life cycle models support this by encouraging continuous improvement. As Talreja (2025) explains, regular cycles of review help systems grow naturally and stay aligned with user expectations as technology changes. [teachingagile.com] Life cycle thinking also strengthens project management because it provides structure for allocating resources, setting priorities, and tracking progress across all phases of the project. FutureCode (2025) highlights that this kind of structured planning helps maintain predictable results and efficient operations in complex or mission critical systems. [future-code.dev] Over the long term, adopting an SDLC approach reduces total system costs because early planning reduces the need for major rework later and helps prevent costly design errors. Teams that consider long term needs from the beginning create systems that are easier and more affordable to support throughout their operational life.

            The Systems Development Life Cycle remains a core framework in software engineering and digital system design. Whether implemented through a linear, iterative, or incremental model, the SDLC provides structure, reduces risk, and enhances the quality of digital systems. Linear models offer predictability and clarity, though they struggle with changing requirements. Iterative models introduce flexibility, faster learning cycles, and continuous feedback, while incremental models deliver modular functionality and early value. Thinking in terms of system life cycles extends beyond development: it influences sustainability, security, maintainability, and system evolution. In an era where digital systems underpin essential services and everyday operations, adopting systematic life cycle approaches is not only beneficial but essential for long-term success and resilience.   

            <footer class="article-footer">
               <h3>Sources:</h3>
               <ol>

<!--INSTRUCTOR COMMENT: Wrap each reference below in listed item tags and all links need to use the anchor element. I've done the first one for you as an example. -->                  
                  <li>GeeksforGeeks. (2026). Software development models – SDLC models. <a href="https://www.geeksforgeeks.org/software-engineering/sdlc-models-types-phases-use/">https://www.geeksforgeeks.org/software-engineering/sdlc-models-types-phases-use/</a> [geeksforgeeks.org]</li>

                  ReliaSoftware. (2024). 8 common software development life cycle methodologies. https://reliasoftware.com/blog/software-development-life-cycle-sdlc-methodologies [reliasoftware.com]

                  Talreja, A. (2025). Iterative model: Advantages, disadvantages & examples. TeachingAgile. https://teachingagile.com/sdlc/models/iterative [teachingagile.com]
                  Visure Solutions. (n.d.). Systems Development Life Cycle (SDLC) models. https://visuresolutions.com/alm-guide/systems-development-life-cycle-models/ [visuresolutions.com]

                  FutureCode IT Consulting. (2025). Software development life cycle (SDLC): Phases, models, and benefits. https://future-code.dev/en/blog/software-development-life-cycle-sdlc-phases-models-and-benefits/ [future-code.dev]
                  Baeldung. (2024). Linear vs. iterative process flows. https://www.baeldung.com/cs/linear-vs-iterative-process-flows [baeldung.com]

               </ol>
            </footer>
         </article>

         <!-- Module 1.2 Blog Post Starts here -->

         <!-- Module 2.1 Blog Post Starts here -->

         <!-- Module 2.2 Blog Post Starts here -->

         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
Works Cited. 



       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>