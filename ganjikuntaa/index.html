<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="css/styles.css" rel="stylesheet">
      <title>Arya Ganjikunta | Portfolio</title>
   </head>
   <body>
<!-- Page Header  -->
      <header class="page-header">
         <h1>Portfolio</h1>
      </header>
<!-- Main Content Area  -->
      <main>
         <!-- Module 1.1 Blog Post Starts Here-->
         <article>
            <header class="article-header">
               <h2>Module 1.1 Blog Post</h2>
            </header>
            <h3>What Systems thinking means to me</h3>
            <p>Before I read through a few sources, systems thinking to me just meant a collection of parts working together just as how I see any other physical system in the world. If something breaks, then you fix it and move on. This mindset of thinking does work but only with simple tools, when it comes to larger digital systems it isn’t as simple as this. Systems thinking feels less like repairing parts and more about understanding relationships between different aspects. Instead of seeing why something is failing it’s important to see what interactions led to this problem. Systems thinking is the mindset of seeing any product, organization, or digital environment as more of a network of connected elements that usually influence each other over time. Instead of just isolating problems it forces you to look at patterns, feedback loops, delays, and unintentional consequences. It’s more focused on the structure of the elements instead of the detail. Holt (2019) describes systems thinking as recognizing that systems behave differently than their individual components would make you think. This is important because when you change one part of the system it affects the others which can lead to unexpected results from a single change. For example, a bug fix or a feature update could solve one issue in one section but create three more issues in another section.</p>
            <h3>How Systems Thinking is Different from Linear Thinking</h3>
            <p>Linear thinking is usually when you see things in the form of steps. Like if you do A, B, and C then you expect an outcome of D. This way of thinking assumes that causes and effects are completely predictable and direct. In the real world and especially in more software focused ecosystems this would not work since things do not work that way. Linear thinking works well for tasks like following a recipe or assembling furniture. However digital systems aren’t recipes they are closer to an ecosystem. A small change of code in one microservice could affect dozens of dependent services which could change performance, change security exposure, or affect user experience all at once. Meadows (2008) explains that linear thinking makes us treat problems as static, but systems are dynamic. They evolve, respond, and learn. A system that works perfectly today could fail tomorrow because of a new workload, new users, or new constraints. For example, when a company introduces a new feature that’s meant to improve user engagement, the linear expectation here is that the engagement increases. The way systems thinking approaches this is they see that it might increase server loads, introduce new attack opportunities, frustrate power users, or even reduce performance for people on certain devices. These sort of effects aren’t that obvious to most people unless you have trained yourself to look for the interactions instead of the outcomes. </p>
            <h3>Why Digital Systems Demand Systems Thinking</h3>
            <p>Our modern digital systems don’t require systems thinking just because they’re big, it’s also the fact that they are interdependent. API’s talk to databases which gives information to analytics platforms, which drive machine learning models, which influence what business decisions are made. No part really exists alone or isolated from everything else. INCOSE (2022) says that complexity grows not from size but from connectivity. The more connected a system becomes the more unpredictable it is. This unpredictability is what can cause outages, data leaks, or some sort of system failure. This is why systems thinking isn’t really optional within the Information Technology industry anymore. It’s part of the base knowledge needed to succeed. Without it engineers can build solutions that are optimized locally but would be globally broken. You might improve one metric which sneakily destroys another more important one. </p>
            <h3>What Model-Based Systems Engineering Adds</h3>
            <p>Systems thinking changes more of how you see the problem. Model-Based Systems Engineering changes how you design the solution. MBSE replaces static documentation with living models that show requirements, behavior, structure, and constraints in a more formal way. Instead of writing long Word documents that take a long time to read, these engineers build interconnected diagrams that update automatically as the system evolves. (Holt, 2019) The real power of MBSE isn’t for the convenience it’s the alignment of everything. Every requirement is connected to a design element, every design element is connected to a test case. When something changes the model shows the ripple effect immediately. </p>
            <h3>Why Traditional Documentation Fails at Scale</h3>
            <p>In traditional development environments documentation is more fragmented. One team writes requirements while another designs the system. Another person tests it. Over time these documents end up drifting apart. This means the system changes but the documentation doesn’t. This leads to situations where nobody fully understands the system anymore. New engineers usually kind of go off instinct or more tribal knowledge. Bugs get fixed by habit instead of insight. MBSE gets rid of this problem by making the model the single source of truth. According to INCOSE (2022), organizations using MBSE report fewer integration errors, better risk management, and faster onboarding for new engineers. That is not because MBSE makes people smarter it just makes the complexity more visible. </p>
            <h3>MBSE as a Tool for Thinking, Not Just Designing</h3>
            <p>One of the most important things I learned from this reading is that MBSE is not just a technical framework its also a thinking framework. It forces you to think in relationships not in features. Instead of wondering how we are supposed to build a model it’s more what role does this module play in the system. You stop optimizing for speed alone and start optimizing for resilience and more long term sustainability overall.</p>
            <h3>Why MBSE Fits Modern Digital Environments</h3>
            <p>Digital environments change constantly such as new technology that gets created, security threats that evolve, and user expectations that change. MBSE gives you a way to adapt without losing control of the system. Meadows (2008) says that systems fail most often when designers misunderstand leverage points which are the small changes that can have a big effect. MBSE emphasizes these leverage points by showing how tight knit parts of the system are. This matters especially in cloud based architectures where services auto scale and communicate and evolve independently. Without a model no one can reliably predict how the system will act under stress.</p>
            <h3>What this means for me as a student</h3>
            <p>Before this assignment I thought systems engineering was mostly about the process but now I know it’s also about the mindset. Systems thinking isn’t really just limited to the office or work environment, I realized I can use it in my daily life and actually use it as an advantage. It has made me more aware of being careful with quick fixes and more curious about the system part of it, like what is the root cause. Instead of asking why something is broken I would ask what relationships made it break. MBSE is basically that mindset put into a physical form that allows you to take action on it. </p>
            <h3>Conclusion</h3>
            <p>Systems thinking is centered around seeing beyond just seeing the parts and actually looking at patterns. It doesn’t allow you to think in assumptions but actually observe and confront the reality of the complexity. MBSE gives us the structure to use that understanding in the real world. Together they are the foundation of systems engineering. Without them digital systems grow faster than our ability to control them. With them we can design environments that can evolve without collapsing or having issues.</p3>
            <footer class="article-footer">
  <h3>Sources</h3>
  <ol>
    <li>
      Holt, J. (2023). <em>Systems engineering demystified: Apply modern, model-based systems engineering techniques to build complex systems</em> (2nd ed.). Packt Publishing.
      <a href="https://searchlib.cwu.edu/discovery/fulldisplay?docid=cdi_globaltitleindex_catalog_406921727&context=PC&vid=01ALLIANCE_CWU:CWU&lang=en&search_scope=CWU_MORE&adaptor=Primo%20Central&tab=CWU_MORE&query=any,contains,Systems%20engineering%20demystified">https://searchlib.cwu.edu/...</a>
    </li>
    <li>
      Olwell, D. H., Henry, D., Pyster, A., Hutchison, N., Enck, S., &amp; Anthony, J. F. (2013). Analysis of the references from the Guide to the Systems Engineering Body of Knowledge (SEBoK). <em>Procedia Computer Science, 16</em>, 1000–1006. https://doi.org/10.1016/j.procs.2013.01.105
    </li>
    <li>
      Meadows, D. H., &amp; Wright, D. (2008). <em>Thinking in systems: A primer</em>. Chelsea Green Publishing.
      <a href="https://adams.marmot.org/Record/.b33648414/Cite">https://adams.marmot.org/...</a>
    </li>
  </ol>
</footer>


         <!-- Module 1.2 Blog Post Starts here -->
<article>
            <header class="article-header">
               <h2>Module 1.2 Blog Post</h2>
            </header>
            <h3>The Systems Development Lifecycle</h3>
            <p>The systems development life cycle refers to the structured stages a system goes through from the initial concept until the end of the system. Most models have phases like planning, requirements analysis, design, implementation, testing, deployment, operation, maintenance, and disposal (Holt, 2023). This framework becomes more useful once you realize that systems don’t just exist in one single moment. They usually exist over time and decisions that were made early on in making it could continue to affect the system even a long time after it’s deployed. What stands out to me is that the SDLC isn’t as focused on following a fixed set of steps its more about trying to maintain control over risks and changes. </p>
            <h3>The Linear Life Cycle Model</h3>
            <p>The linear life cycle model which is also known as the waterfall model follows a sequence of events that progress from one phase to the next. They usually move from requirements to design, implementation to testing, and deployment without really overlapping steps. (Pressman, 2010). This shows that each phase is expected to be completed before going on to the next. One of the main advantages of this model is the clarity. Planning and scheduling are more straightforward with this model because each phase is very clearly defined. This would be more useful in an environment where there are formal approval processes or there are heavy regulations you have to follow. The model is also good for traceability because all the requirements are directly linked to the different parts of the system. One disadvantage is that this model depends on whether or not you are able to define all the requirements fully at the beginning of the project. This is usually not how it works in the real world. The users are always changing and some technical problems might not be evident until the development is started. When errors happen early in the process they are usually discovered late which increases the cost and complexity of fixing them (Boehm, 1988). This makes the linear model not that good for more complicated systems or systems that are constantly evolving. </p>
            <h3>The Iterative Life Cycle Model</h3>
            <p>The iterative life cycle has a different approach than the linear one. This model repeats the development process multiple times where each cycle makes a more refined version of the system (Holt, 2023). This model doesn’t have all the requirements up front it actually learns it through the development cycles. What this means for the model is that it accepts the uncertainty instead of trying to eliminate it. The earlier versions of the system will test assumptions and gather feedback, then identify problems that weren’t there during the initial planning. Then with that information you can incorporate solutions into different iterations which leads to improvement over time. One advantage of this model is that it lowers the chance of building a system that doesn’t meet user needs even if it technically works for the documented requirements. This is due to the fact that feedback is constantly incorporated into the way the system changes and evolves and the fact that it responds to real usage. However, there are still some issues that can come with this model. The main potential issue is regarding scope control and scheduling. If the model doesn’t have clear boundaries then it can grow way farther than what was intended originally. This means that the timelines can become difficult to predict. So to prevent this the model needs to be managed carefully so that it doesn’t become inconsistent from it’s growth. </p>
            <h3>Incremental Life Cycle Model</h3>
            <p>The incremental life cycle model is more focused on delivering the system in a series of functional increments with each increment adding new parts or capabilities to the system (Pressman, 2010). Each release is meant to be fully operational and stable so not really a prototype. This type of approach allows for the stakeholders of the project to test parts of the system or fully use them before the whole thing is complete. Because of this the feedback value is given to the system quicker and its feedback would be based on real use instead of hypothetical scenarios. This makes it so the risk is lesser since it’s more distributed instead of being one single deployment with a huge chance of risk. Again though, there are a few disadvantages. It’s not that big of a disadvantage but the whole model depends on how strong the architectural planning for it is. If some of the early increments have bad structure they can end up creating long term maintenance problems or limit the model. Managing all the individual dependencies among the increments would also be an issue because sometimes some of the features might rely on something that hasn’t been created or implemented yet. For example if one increment has two dependencies in the increment that’s supposed to come after it then it wouldn’t work properly without them.</p>
            <h3>Why Lifecycle Thinking is Important</h3>
            <p>The mindset of lifecycle thinking isn’t necessarily too focused on building the system but it’s more focused on sustaining it. Instead of just using an evaluation from the success of deploying the system this mindset would measure the success of the system based on how the system will perform and evolve over time. One reason for this is that a lot of early designing decisions can end up having long term consequences. Architectural choices, technology sections, and interface standards shape how easily a system can be updated, scaled, or integrated with other systems in the future (Holt, 2023). The system could work perfectly at the beginning but that could become the reason that it becomes difficult or expensive to maintain it down the line. A life cycle thinking cycle also helps with sustainability. Most of these systems end up using quite a few resources throughout their lifetime such as energy use or maintenance costs which all contribute to the system’s overall impact. Considering these factors across the entire life cycle allows engineers to make decisions that reduce long term costs and environmental impact (Boehm, 1988). Another thing that is very clear here is that change is not something you can avoid. Its either that technology is constantly evolving or user needs constantly change with a few other factors. The life cycle thinking mindset sees this as a completely normal part of the process instead of an exception. This is kind of similar to iterative and incremental models in terms of how they use adaptation as a big part of the model instead of seeing the changes that happen as a disruption.</p>
            <h3>Choosing Between Life Cycle Models</h3>
            <p>The way I see it there isn’t really one life cycle model that works the best for all situations. This is because each model is based on different assumptions regarding stability and risk. The linear model would be the best when the requirements are stable and risks are very well defined, especially when formal documentation is needed. The iterative model is better for environments where the requirements aren’t as clear so you have to use learning to understand the whole process. The incremental model is better when early delivery matters and the system can be built in different independent but functional parts. In the real world many projects combine different aspects of each model. The main thing that matters more than just sticking to one model because it has worked before is that the approach makes sense with what the system’s context and constraints are.</p>
            <h3>Conclusion</h3>
            <p>The systems development life cycle gives a good structured way to understand how systems are created and used. The three different models such as linear, iterative, and incremental models give different ways of organizing this process each with its own strengths and weaknesses. The need for different models is due to the fact that nowadays most systems aren’t static. They tend to change over time and the way you develop the system has to account for that. The life cycle thinking mindset teaches engineers to not worry as much about the short term delivery and more about the long term where adaptability and sustainability are part of the core aspects of the system. </p>
            
            <footer class="article-footer">
  <h3>Sources</h3>
  <ol>
    <li>
      Holt, J. (2023). <em>Systems engineering demystified: Apply modern, model-based systems engineering techniques to build complex systems</em> (2nd ed.). Packt Publishing.
      <a href="https://searchlib.cwu.edu/discovery/fulldisplay?docid=cdi_globaltitleindex_catalog_406921727&context=PC&vid=01ALLIANCE_CWU:CWU&lang=en&search_scope=CWU_MORE&adaptor=Primo%20Central&tab=CWU_MORE&query=any,contains,Systems%20engineering%20demystified">https://searchlib.cwu.edu/...</a>
    </li>
    <li>
      Boehm, B. W. (1988). A spiral model of software development and enhancement. Computer (Long Beach, Calif.), 21(5), 61–72. https://www.cse.msu.edu/~cse435/Homework/HW3/boehm.pdf
    </li>
    <li>
      Pressman, R. S. (2010).  <em>Software engineering : a practitioner’s approach (Seventh edition, alternate edition.). McGraw-Hill Higher Education. </em> https://drive.google.com/file/d/0B4FvADGfA7T8S3lCNE1IZlpQc1E/view?resourcekey=0-O9gbq1v6Nhr4ZisAbOJ_hg
    </li>
  </ol>
</footer>
         <!-- Module 2.1 Blog Post Starts here -->

         <!-- Module 2.2 Blog Post Starts here -->

         <!-- Module 2.3 Blog Post Starts here -->

         <!-- Module 3.1 Blog Post Starts here -->

         <!-- Module 3.2 Blog Post Starts here -->

      </main>
<!-- Page Footer  -->
      <footer class="page-footer">
       <p>Copyright &copy; 2025</p>
      </footer>
   </body>
</html>